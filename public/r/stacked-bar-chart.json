{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "stacked-bar-chart",
  "type": "registry:chart",
  "title": "Stacked Bar Chart",
  "description": "D3-powered stacked bar chart component with multiple data categories stacked vertically, tooltips, and responsive sizing",
  "dependencies": ["d3"],
  "registryDependencies": ["chart-utils"],
  "files": [
    {
      "path": "components/charts/stacked-bar-chart.tsx",
      "type": "registry:chart",
      "content": "import { select, stack } from \"d3\";\nimport {\n  type Component,\n  createEffect,\n  createMemo,\n  For,\n  on,\n  onMount,\n  Show,\n} from \"solid-js\";\nimport {\n  type ChartMargin,\n  calculateDimensions,\n  chartStyles,\n  createAxisGenerator,\n  createBandScale,\n  createColorScale,\n  createLinearScale,\n  defaultColorPalette,\n  getColorFromPalette,\n  getRelativeMousePosition,\n  renderAxis,\n  styleAxis,\n  styleGridLines,\n  useChartTooltip,\n  useResizeObserver,\n} from \"~/lib/charts\";\n\nexport type StackedBarDataPoint = {\n  category: string;\n  [key: string]: string | number;\n};\n\nexport type StackedBarChartProps = {\n  data: StackedBarDataPoint[];\n  keys: string[];\n  keyLabels?: Record<string, string>;\n  width?: number;\n  height?: number;\n  margin?: Partial<ChartMargin>;\n  xAxisLabel?: string;\n  yAxisLabel?: string;\n  showGrid?: boolean;\n  showLegend?: boolean;\n  animate?: boolean;\n  barPadding?: number;\n  colors?: readonly string[];\n  class?: string;\n};\n\ntype TooltipContent = {\n  category: string;\n  key: string;\n  keyLabel: string;\n  value: number;\n  total: number;\n  color: string;\n};\n\nexport const StackedBarChart: Component<StackedBarChartProps> = (props) => {\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let containerRef: HTMLDivElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let svgRef: SVGSVGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let xAxisRef: SVGGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let yAxisRef: SVGGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let gridRef: SVGGElement | undefined;\n\n  const tooltip = useChartTooltip<TooltipContent>();\n\n  const containerSize = useResizeObserver(() => containerRef, {\n    debounceMs: 100,\n  });\n\n  const dimensions = createMemo(() => {\n    const width = props.width ?? containerSize().width;\n    const height = props.height ?? containerSize().height ?? 300;\n    return calculateDimensions(width, height, props.margin);\n  });\n\n  const colorScale = createMemo(() => {\n    const colors = props.colors ?? defaultColorPalette;\n    return createColorScale(props.keys, colors);\n  });\n\n  const categories = createMemo(() => props.data.map((d) => d.category));\n\n  const stackedData = createMemo(() => {\n    const stackGenerator = stack<StackedBarDataPoint>().keys(props.keys);\n    return stackGenerator(props.data);\n  });\n\n  const xScale = createMemo(() => {\n    const { innerWidth } = dimensions();\n    return createBandScale(categories(), [0, innerWidth], {\n      padding: props.barPadding ?? 0.2,\n    });\n  });\n\n  const yScale = createMemo(() => {\n    const { innerHeight } = dimensions();\n    const maxY = Math.max(\n      ...props.data.map((d) => {\n        let sum = 0;\n        for (const key of props.keys) {\n          const val = d[key];\n          if (typeof val === \"number\") {\n            sum += val;\n          }\n        }\n        return sum;\n      })\n    );\n    return createLinearScale([0, maxY * 1.1], [innerHeight, 0], {\n      nice: true,\n    });\n  });\n\n  const getKeyColor = (key: string, index: number): string =>\n    colorScale()(key) ??\n    getColorFromPalette(index, props.colors ?? defaultColorPalette);\n\n  const getKeyLabel = (key: string): string => props.keyLabels?.[key] ?? key;\n\n  onMount(() => {\n    if (xAxisRef && yAxisRef) {\n      updateAxes();\n    }\n  });\n\n  const updateAxes = () => {\n    const { innerWidth, innerHeight } = dimensions();\n\n    if (xAxisRef) {\n      const xAxis = createAxisGenerator(\"bottom\", xScale(), {\n        tickCount: categories().length,\n      });\n      renderAxis(xAxisRef, xAxis);\n      styleAxis(xAxisRef);\n    }\n\n    if (yAxisRef) {\n      const yAxis = createAxisGenerator(\"left\", yScale(), {\n        tickCount: Math.floor(innerHeight / 50),\n      });\n      renderAxis(yAxisRef, yAxis);\n      styleAxis(yAxisRef);\n    }\n\n    if (gridRef && props.showGrid !== false) {\n      const gridAxis = createAxisGenerator(\"left\", yScale(), {\n        tickCount: Math.floor(innerHeight / 50),\n        tickSize: -innerWidth,\n      });\n      select(gridRef).call(gridAxis);\n      styleGridLines(gridRef);\n    }\n  };\n\n  createEffect(\n    on([dimensions, xScale, yScale], () => {\n      updateAxes();\n    })\n  );\n\n  const handleMouseMove = (event: MouseEvent) => {\n    if (!svgRef) {\n      return;\n    }\n\n    const { margin } = dimensions();\n    const mousePos = getRelativeMousePosition(event, svgRef);\n    const adjustedX = mousePos.x - margin.left;\n    const adjustedY = mousePos.y - margin.top;\n\n    const closest = findClosestBar(adjustedX, adjustedY);\n\n    if (closest) {\n      tooltip.show(closest, { x: mousePos.x, y: mousePos.y });\n    } else {\n      tooltip.hide();\n    }\n  };\n\n  const computeTotal = (dataIndex: number): number => {\n    let total = 0;\n    for (const k of props.keys) {\n      const val = props.data[dataIndex][k];\n      if (typeof val === \"number\") {\n        total += val;\n      }\n    }\n    return total;\n  };\n\n  const isPointInBar = (opts: {\n    mouseX: number;\n    mouseY: number;\n    barX: number;\n    bandwidth: number;\n    barY0: number;\n    barY1: number;\n  }): boolean =>\n    opts.mouseX >= opts.barX &&\n    opts.mouseX <= opts.barX + opts.bandwidth &&\n    opts.mouseY >= opts.barY1 &&\n    opts.mouseY <= opts.barY0;\n\n  const findClosestBar = (\n    mouseX: number,\n    mouseY: number\n  ): TooltipContent | null => {\n    const xS = xScale();\n    const yS = yScale();\n    const bandwidth = xS.bandwidth();\n\n    for (let keyIndex = 0; keyIndex < stackedData().length; keyIndex++) {\n      const seriesData = stackedData()[keyIndex];\n      const key = props.keys[keyIndex];\n\n      for (let i = 0; i < seriesData.length; i++) {\n        const d = seriesData[i];\n        const category = props.data[i].category;\n        const barX = xS(category) ?? 0;\n        const barY0 = yS(d[0]);\n        const barY1 = yS(d[1]);\n\n        if (isPointInBar({ mouseX, mouseY, barX, bandwidth, barY0, barY1 })) {\n          return {\n            category,\n            key,\n            keyLabel: getKeyLabel(key),\n            value: d[1] - d[0],\n            total: computeTotal(i),\n            color: getKeyColor(key, keyIndex),\n          };\n        }\n      }\n    }\n\n    return null;\n  };\n\n  const handleMouseLeave = () => {\n    tooltip.hide();\n  };\n\n  const formatTooltipValue = (value: number | undefined): string => {\n    if (value === undefined) {\n      return \"\";\n    }\n    return value.toLocaleString(undefined, {\n      maximumFractionDigits: 2,\n    });\n  };\n\n  return (\n    <div\n      class={`relative w-full ${props.class ?? \"\"}`}\n      ref={containerRef}\n      style={{ \"min-height\": `${props.height ?? 300}px` }}\n    >\n      <Show when={dimensions().width > 0 && dimensions().height > 0}>\n        {/* biome-ignore lint/a11y/noSvgWithoutTitle: Chart with programmatic tooltip */}\n        {/* biome-ignore lint/a11y/noNoninteractiveElementInteractions: Chart interaction */}\n        <svg\n          class=\"select-none\"\n          height={dimensions().height}\n          onMouseLeave={handleMouseLeave}\n          onMouseMove={handleMouseMove}\n          ref={svgRef}\n          width={dimensions().width}\n        >\n          <g\n            transform={`translate(${dimensions().margin.left},${dimensions().margin.top})`}\n          >\n            <Show when={props.showGrid !== false}>\n              <g class=\"grid\" ref={gridRef} />\n            </Show>\n\n            <For each={stackedData()}>\n              {(seriesData, keyIndex) => {\n                const color = () =>\n                  getKeyColor(props.keys[keyIndex()], keyIndex());\n\n                return (\n                  <g class=\"series\">\n                    <For each={seriesData}>\n                      {(d, i) => {\n                        const barX = () =>\n                          xScale()(props.data[i()].category) ?? 0;\n                        const barY = () => yScale()(d[1]);\n                        const barWidth = () => xScale().bandwidth();\n                        const barHeight = () => yScale()(d[0]) - yScale()(d[1]);\n\n                        return (\n                          <rect\n                            fill={color()}\n                            height={Math.max(0, barHeight())}\n                            rx={2}\n                            ry={2}\n                            width={barWidth()}\n                            x={barX()}\n                            y={barY()}\n                          />\n                        );\n                      }}\n                    </For>\n                  </g>\n                );\n              }}\n            </For>\n\n            <g\n              class=\"x-axis\"\n              ref={xAxisRef}\n              transform={`translate(0,${dimensions().innerHeight})`}\n            />\n            <g class=\"y-axis\" ref={yAxisRef} />\n\n            <Show when={props.xAxisLabel}>\n              <text\n                fill={chartStyles.axis.text}\n                font-size={chartStyles.axis.fontSize}\n                text-anchor=\"middle\"\n                x={dimensions().innerWidth / 2}\n                y={dimensions().innerHeight + dimensions().margin.bottom - 5}\n              >\n                {props.xAxisLabel}\n              </text>\n            </Show>\n\n            <Show when={props.yAxisLabel}>\n              <text\n                fill={chartStyles.axis.text}\n                font-size={chartStyles.axis.fontSize}\n                text-anchor=\"middle\"\n                transform=\"rotate(-90)\"\n                x={-dimensions().innerHeight / 2}\n                y={-dimensions().margin.left + 15}\n              >\n                {props.yAxisLabel}\n              </text>\n            </Show>\n          </g>\n        </svg>\n\n        <Show when={props.showLegend !== false && props.keys.length > 1}>\n          <div class=\"mt-4 flex flex-wrap justify-center gap-4\">\n            <For each={props.keys}>\n              {(key, index) => (\n                <div class=\"flex items-center gap-2\">\n                  <span\n                    class=\"h-3 w-3 rounded-full\"\n                    style={{ background: getKeyColor(key, index()) }}\n                  />\n                  <span class=\"text-muted-foreground text-sm\">\n                    {getKeyLabel(key)}\n                  </span>\n                </div>\n              )}\n            </For>\n          </div>\n        </Show>\n\n        <Show when={tooltip.isVisible()}>\n          <div\n            class=\"pointer-events-none absolute z-50 rounded-md border px-3 py-2 shadow-md\"\n            style={{\n              left: `${tooltip.state().position.x + 10}px`,\n              top: `${tooltip.state().position.y + 10}px`,\n              background: chartStyles.tooltip.background,\n              border: `1px solid ${chartStyles.tooltip.border}`,\n              color: chartStyles.tooltip.text,\n              \"box-shadow\": chartStyles.tooltip.shadow,\n            }}\n          >\n            <div class=\"flex items-center gap-2\">\n              <span\n                class=\"h-2 w-2 rounded-full\"\n                style={{ background: tooltip.state().data?.color }}\n              />\n              <span class=\"font-medium\">{tooltip.state().data?.keyLabel}</span>\n            </div>\n            <div class=\"mt-1 text-muted-foreground text-sm\">\n              <div>{tooltip.state().data?.category}</div>\n              <div class=\"font-medium text-foreground\">\n                {formatTooltipValue(tooltip.state().data?.value)}\n              </div>\n              <div class=\"text-xs\">\n                Total: {formatTooltipValue(tooltip.state().data?.total)}\n              </div>\n            </div>\n          </div>\n        </Show>\n      </Show>\n    </div>\n  );\n};\n\nexport default StackedBarChart;\n"
    }
  ]
}
