{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gatehouse",
  "type": "registry:lib",
  "title": "Gatehouse",
  "description": "A flexible, zero-dependencies authorization TypeScript library supporting RBAC, ABAC, and ReBAC",
  "dependencies": [],
  "files": [
    {
      "path": "lib/gatehouse.ts",
      "type": "registry:lib",
      "content": "/**\n * Gatehouse-TS - A flexible, zero-dependencies authorization TypeScript library\n * Supports RBAC, ABAC, and ReBAC access control patterns\n * \n * Based on the Gatehouse library for Rust by Hardbyte and Partly\n * TypeScript port by gr4vityWall (9Morello)\n * \n * @license Apache-2.0\n * @see https://github.com/9Morello/gatehouse-ts\n */\n\n/**\n * Operation types for combining policies.\n */\nconst CombineOp = Object.freeze({\n  And: 'AND',\n  Or: 'OR',\n  Not: 'NOT',\n});\n\ntype Operation = (typeof CombineOp)[keyof typeof CombineOp];\n\n/**\n * Base class for policy evaluation results.\n * Contains information about whether access was granted and why.\n */\nabstract class PolicyEvalResult {\n  public readonly policyType: string;\n  public readonly reason: string | null;\n  constructor({ policyType, reason }: { policyType: string; reason?: string | null }) {\n    this.policyType = policyType;\n    this.reason = reason ?? null;\n  }\n\n  abstract isGranted(): boolean;\n  abstract format(): string;\n}\n\n/**\n * Represents a successful policy evaluation that grants access.\n */\nclass GrantedAccessResult extends PolicyEvalResult {\n  isGranted(): boolean {\n    return true;\n  }\n  format(): string {\n    return `[GRANTED] ${this.policyType}${this.reason ? ' ' + this.reason : ''}`;\n  }\n}\n\n/**\n * Represents a failed policy evaluation that denies access.\n */\nclass DeniedAccessResult extends PolicyEvalResult {\n  isGranted(): boolean {\n    return false;\n  }\n  format(): string {\n    return `[DENIED] ${this.policyType}: ${this.reason ? ' ' + this.reason : ''}`;\n  }\n}\n\n/**\n * Represents a combined result from multiple policies.\n * Used for AND, OR, and NOT policy combinations.\n */\nclass CombinedResult extends PolicyEvalResult {\n  private readonly outcome: boolean;\n  private readonly operation: Operation;\n  private readonly children: PolicyEvalResult[];\n\n  constructor({\n    policyType,\n    outcome,\n    operation,\n    children,\n  }: {\n    policyType: string;\n    outcome: boolean;\n    operation: Operation;\n    children: PolicyEvalResult[];\n  }) {\n    super({ policyType, reason: null });\n    this.outcome = outcome;\n    this.operation = operation;\n    this.children = children;\n  }\n  isGranted(): boolean {\n    return this.outcome;\n  }\n  format(): string {\n    const outcomeChar: string = this.outcome ? '[GRANTED]' : '[DENIED]';\n    const toplevelMessage = `${outcomeChar} ${this.policyType} (${this.operation})`;\n    return [toplevelMessage, ...this.children.map((child) => '  ' + child.format())].join(\n      '\\n'\n    );\n  }\n\n  display() {\n    console.log(this.format());\n  }\n}\n\n/**\n * Contains the full evaluation trace for debugging policy decisions.\n */\nclass EvalTrace {\n  private readonly root: PolicyEvalResult | null;\n\n  constructor(root: PolicyEvalResult | null = null) {\n    this.root = root;\n  }\n\n  format(): string {\n    return this.root?.format() || 'No evaluation trace available';\n  }\n}\n\n/**\n * Final result of an access evaluation.\n * Contains the outcome (granted/denied), reason, and full evaluation trace.\n *\n * @example\n * const result = await permissionChecker.evaluateAccess({\n *   subject: user,\n *   resource: document,\n *   action: \"edit\",\n *   context: {}\n * });\n *\n * if (result.isGranted()) {\n *   // Allow the action\n * } else {\n *   console.log(\"Access denied:\", result.getDisplayTrace());\n * }\n */\nclass AccessEvaluation {\n  private readonly outcome: 'Granted' | 'Denied';\n  private readonly trace: EvalTrace;\n  private readonly policyType: string | null;\n  public readonly reason: string | null;\n  private constructor({\n    outcome,\n    reason,\n    policyType,\n    trace,\n  }:\n    | {\n        outcome: 'Granted';\n        reason?: string | null;\n        policyType: string;\n        trace: EvalTrace;\n      }\n    | {\n        outcome: 'Denied';\n        reason: string;\n        policyType?: null;\n        trace: EvalTrace;\n      }) {\n    this.outcome = outcome;\n    this.trace = trace;\n    this.reason = reason || null;\n    this.policyType = policyType || null;\n  }\n\n  static denied(reason: string, trace: EvalTrace): AccessEvaluation {\n    return new AccessEvaluation({\n      reason,\n      policyType: null,\n      trace,\n      outcome: 'Denied',\n    });\n  }\n\n  static granted(\n    policyType: string,\n    trace: EvalTrace,\n    reason: string | null = null\n  ): AccessEvaluation {\n    return new AccessEvaluation({\n      reason,\n      policyType,\n      trace,\n      outcome: 'Granted',\n    });\n  }\n\n  /**\n   * Returns whether access was granted.\n   *\n   * @returns true if access was granted, false otherwise\n   */\n  isGranted(): boolean {\n    return this.outcome === 'Granted';\n  }\n\n  /**\n   * Returns a formatted string with the evaluation trace for debugging.\n   *\n   * @returns Formatted evaluation trace\n   */\n  getDisplayTrace(): string {\n    const traceString = this.trace.format();\n    return traceString !== 'No evaluation trace available'\n      ? `\\nEvaluation Trace:\\n${traceString}`\n      : `\\n(${traceString})`;\n  }\n\n  /**\n   * Prints the evaluation result to the console.\n   */\n  print() {\n    if (this.outcome === 'Granted') {\n      console.log(\n        `[GRANTED] by ${this.policyType}${this.reason ? ` - ${this.reason}` : ''}`\n      );\n    } else {\n      console.log(`[DENIED] - ${this.reason}`);\n    }\n  }\n}\n\n/**\n * Function type for evaluating access based on subject, resource, action, and context.\n *\n * @template Subject - The type of the subject requesting access\n * @template Resource - The type of resource being accessed\n * @template Action - The type of action being performed\n * @template Context - Additional contextual information\n */\ntype EvaluateAccess<Subject, Resource, Action, Context> = ({\n  subject,\n  resource,\n  action,\n  context,\n}: {\n  subject: Subject;\n  resource: Resource;\n  action: Action;\n  context: Context;\n}) => PolicyEvalResult | Promise<PolicyEvalResult>;\n\n/**\n * Interface for all policy types in the system.\n *\n * @template Subject - The type of the subject requesting access\n * @template Resource - The type of resource being accessed\n * @template Action - The type of action being performed\n * @template Context - Additional contextual information\n */\ninterface Policy<Subject, Resource, Action, Context> {\n  /**\n   * @param subject The entity requesting access.\n   * @param action The action being performed.\n   * @param resource The target resource.\n   * @param context Additional context that may affect the decision.\n   */\n  readonly evaluateAccess: EvaluateAccess<Subject, Resource, Action, Context>;\n\n  /**\n   * Policy name for debugging.\n   */\n  readonly name: string;\n}\n\n/**\n * Main class for evaluating access permissions. Add multiple policies to it,\n * and it will evaluate them sequentially until one grants access.\n *\n * @template Sub - The type of the subject requesting access\n * @template Res - The type of resource being accessed\n * @template Act - The type of action being performed\n * @template Ctx - Additional contextual information\n *\n * @example\n * const checker = new PermissionChecker<User, Document, string, RequestContext>();\n * checker.addPolicy(adminPolicy);\n * checker.addPolicy(ownerPolicy);\n * const result = await checker.evaluateAccess({\n *   subject: currentUser,\n *   resource: document,\n *   action: \"edit\",\n *   context: requestContext\n * });\n * if (result.isGranted()) {\n *   // Allow access\n * }\n */\nclass PermissionChecker<Sub, Res, Act, Ctx> {\n  private policies: Policy<Sub, Res, Act, Ctx>[];\n  public readonly name: string = 'PermissionChecker';\n  constructor() {\n    this.policies = [];\n  }\n\n  /**\n   * Adds a policy to the permission checker.\n   * Policies are evaluated in the order they're added, with OR semantics.\n   *\n   * @param policy The policy to add\n   */\n  addPolicy(policy: Policy<Sub, Res, Act, Ctx>) {\n    this.policies.push(policy);\n  }\n\n  /**\n   * Evaluates access based on the configured policies.\n   * Policies are evaluated sequentially with OR semantics (short-circuiting on first success).\n   *\n   * @param subject The entity requesting access.\n   * @param action The action being performed.\n   * @param resource The target resource.\n   * @param context Additional context that may affect the decision.\n   * @returns AccessEvaluation result with details about the decision\n   */\n  async evaluateAccess({\n    subject,\n    resource,\n    action,\n    context,\n  }: {\n    subject: Sub;\n    resource: Res;\n    action: Act;\n    context: Ctx;\n  }): Promise<AccessEvaluation> {\n    if (!this.policies.length) {\n      const reason: string = 'No policies configured';\n      console.warn(reason);\n      const result = new DeniedAccessResult({\n        policyType: 'PermissionChecker',\n        reason,\n      });\n      return AccessEvaluation.denied(reason, new EvalTrace(result));\n    }\n\n    const policyResults: PolicyEvalResult[] = [];\n    for (const policy of this.policies) {\n      const result: PolicyEvalResult = await policy.evaluateAccess({\n        subject,\n        resource,\n        action,\n        context,\n      });\n      const resultPassed: boolean = result.isGranted();\n      policyResults.push(result);\n\n      if (resultPassed) {\n        const combined = new CombinedResult({\n          policyType: 'PermissionChecker',\n          outcome: true,\n          operation: CombineOp.Or,\n          children: policyResults,\n        });\n        return AccessEvaluation.granted(result.policyType, new EvalTrace(combined));\n      }\n    }\n\n    const combined = new CombinedResult({\n      policyType: 'PermissionChecker',\n      outcome: false,\n      operation: CombineOp.Or,\n      children: policyResults,\n    });\n    return AccessEvaluation.denied('All policies denied access', new EvalTrace(combined));\n  }\n}\n\n/**\n * Represents the intended effect of a policy.\n * `Allow` means the policy grants access; `Deny` means it denies access.\n */\nconst Effect = Object.freeze({\n  Allow: 'Allow',\n  Deny: 'Deny',\n});\n\ntype IntendedEffect = (typeof Effect)[keyof typeof Effect];\n\ntype InternalPolicy<Sub, Res, Act, Ctx> = {\n  name: string;\n\n  effect: IntendedEffect;\n\n  predicate: (\n    subject: Sub,\n    resource: Res,\n    action: Act,\n    context: Ctx\n  ) => boolean | Promise<boolean>;\n};\n\nfunction transformInternalPolicy<Sub, Res, Act, Ctx>(\n  internalPolicy: InternalPolicy<Sub, Res, Act, Ctx>\n): Policy<Sub, Res, Act, Ctx> {\n  const policyName: string = internalPolicy.name;\n  const effect: IntendedEffect = internalPolicy.effect;\n  return Object.freeze({\n    name: policyName,\n    evaluateAccess: async ({\n      subject,\n      resource,\n      action,\n      context,\n    }: {\n      subject: Sub;\n      resource: Res;\n      action: Act;\n      context: Ctx;\n    }): Promise<PolicyEvalResult> => {\n      const predicateResult = await internalPolicy.predicate(\n        subject,\n        resource,\n        action,\n        context\n      );\n      if (predicateResult) {\n        if (effect === Effect.Allow) {\n          return new GrantedAccessResult({\n            policyType: policyName,\n            reason: 'Policy allowed access',\n          });\n        }\n\n        return new DeniedAccessResult({\n          policyType: policyName,\n          reason: 'Policy denied access',\n        });\n      }\n\n      return new DeniedAccessResult({\n        policyType: policyName,\n        reason: 'Policy predicate did not match',\n      });\n    },\n  });\n}\n\n/**\n * Function type for checking if access conditions are met.\n * Used in ABAC policies and other conditional checks.\n *\n * @template Subject - The type of the subject requesting access\n * @template Resource - The type of resource being accessed\n * @template Action - The type of action being performed\n * @template Context - Additional contextual information\n */\ntype Condition<Subject, Resource, Action, Context> = ({\n  subject,\n  resource,\n  action,\n  context,\n}: {\n  subject: Subject;\n  resource: Resource;\n  action: Action;\n  context: Context;\n}) => boolean | Promise<boolean>;\n\n/**\n * A fluent builder for creating custom access policies.\n *\n * @template Sub - The type of the subject requesting access\n * @template Res - The type of resource being accessed\n * @template Act - The type of action being performed\n * @template Ctx - Additional contextual information\n *\n * @example\n * const readOnlyPolicy = new PolicyBuilder<User, Document, string, Context>(\"ReadOnly\")\n *   .actions(action => action === \"read\")\n *   .build();\n */\nclass PolicyBuilder<Sub, Res, Act, Ctx> {\n  private name: string;\n  private internalEffect: IntendedEffect;\n\n  private subjectPred: ((sub: Sub) => boolean | Promise<boolean>) | null = null;\n  private resPred: ((res: Res) => boolean | Promise<boolean>) | null = null;\n  private actionPred: ((act: Act) => boolean | Promise<boolean>) | null = null;\n  private ctxPred: ((ctx: Ctx) => boolean | Promise<boolean>) | null = null;\n  private extraConditionPred: Condition<Sub, Res, Act, Ctx> | null = null;\n\n  constructor(name: string) {\n    this.name = name;\n    this.internalEffect = Effect.Allow;\n  }\n\n  /**\n   * Sets the policy's effect (Allow or Deny).\n   * Default is Allow if not specified.\n   *\n   * @param effect The intended effect (Allow or Deny)\n   */\n  effect(effect: IntendedEffect) {\n    this.internalEffect = effect;\n    return this;\n  }\n\n  /**\n   * Adds a condition based on the subject.\n   *\n   * @param pred Function that evaluates the subject and returns true if access should be granted\n   * @example\n   * .subjects(user => user.roles.includes('admin'))\n   */\n  subjects(pred: (sub: Sub) => boolean | Promise<boolean>) {\n    this.subjectPred = pred;\n    return this;\n  }\n\n  /**\n   * Adds a condition based on the resource.\n   *\n   * @param pred Function that evaluates the resource and returns true if access should be granted\n   * @example\n   * .resources(doc => doc.isPublic)\n   */\n  resources(pred: (res: Res) => boolean | Promise<boolean>) {\n    this.resPred = pred;\n    return this;\n  }\n\n  /**\n   * Adds a condition based on the action.\n   *\n   * @param pred Function that evaluates the action and returns true if access should be granted\n   * @example\n   * .actions(action => action === \"read\" || action === \"list\")\n   */\n  actions(pred: (action: Act) => boolean | Promise<boolean>) {\n    this.actionPred = pred;\n    return this;\n  }\n\n  /**\n   * Adds a condition based on the context.\n   *\n   * @param pred Function that evaluates the context and returns true if access should be granted\n   * @example\n   * .context(ctx => ctx.isBusinessHours)\n   */\n  context(pred: (ctx: Ctx) => boolean | Promise<boolean>) {\n    this.ctxPred = pred;\n    return this;\n  }\n\n  /**\n   * Adds a custom condition that can access all parameters.\n   *\n   * @param pred Function that evaluates all parameters and returns true if access should be granted\n   * @example\n   * .when(({subject, resource}) => subject.id === resource.ownerId)\n   */\n  when(pred: Condition<Sub, Res, Act, Ctx>) {\n    this.extraConditionPred = pred;\n    return this;\n  }\n\n  /**\n   * Builds and returns the policy.\n   *\n   * @returns The constructed policy\n   */\n  build(): Policy<Sub, Res, Act, Ctx> {\n    const {\n      subjectPred,\n      resPred,\n      actionPred,\n      ctxPred,\n      name,\n      internalEffect: effect,\n      extraConditionPred,\n    } = this;\n\n    const combinedPredicate = async (\n      subject: Sub,\n      resource: Res,\n      action: Act,\n      context: Ctx\n    ): Promise<boolean> => {\n      return (\n        (subjectPred === null || (await subjectPred(subject))) &&\n        (resPred === null || (await resPred(resource))) &&\n        (actionPred === null || (await actionPred(action))) &&\n        (ctxPred === null || (await ctxPred(context))) &&\n        (extraConditionPred === null ||\n          (await extraConditionPred({ subject, resource, action, context })))\n      );\n    };\n\n    const internalPolicy = {\n      name,\n      effect,\n      predicate: combinedPredicate,\n    };\n\n    return transformInternalPolicy(internalPolicy);\n  }\n}\n\n/**\n * Interface for role-based access control policies.\n *\n * @template Subject - The subject type\n * @template Resource - The resource type\n * @template Action - The action type\n * @template Context - The context type\n * @template Role - The role type (typically string)\n */\ninterface RoleBasedPolicy<Subject, Resource, Action, Context, Role>\n  extends Policy<Subject, Resource, Action, Context> {\n  requiredRolesResolver: (res: Resource, act: Action) => Role[] | Promise<Role[]>;\n  userRolesResolver: (subject: Subject) => Role[] | Promise<Role[]>;\n  name: string;\n}\n\n/**\n * Creates a Role-Based Access Control policy.\n * Grants access when the subject has at least one of the required roles for the resource/action.\n *\n * @template Sub - Subject type (typically a user)\n * @template Res - Resource type\n * @template Act - Action type\n * @template Ctx - Context type\n * @template Role - Role type (typically string)\n * @param requiredRolesResolver Function that returns the roles required for a resource/action\n * @param userRolesResolver Function that extracts the roles from a subject\n * @returns A RBAC policy\n *\n * @example\n * const rbacPolicy = buildRbacPolicy<User, Document, string, Context, string>({\n *   requiredRolesResolver: (doc, action) =>\n *     action === \"read\" ? [\"user\", \"admin\"] : [\"admin\"],\n *   userRolesResolver: (user) => user.roles\n * });\n */\nfunction buildRbacPolicy<Sub, Res, Act, Ctx, Role>(\n  {\n    requiredRolesResolver,\n    userRolesResolver,\n    name = 'RbacPolicy',\n  }: {\n    requiredRolesResolver: (res: Res, act: Act) => Role[] | Promise<Role[]>;\n    userRolesResolver: (sub: Sub) => Role[] | Promise<Role[]>;\n    name?: string;\n  }\n): RoleBasedPolicy<Sub, Res, Act, Ctx, Role> {\n  const policyType = name;\n  const evaluateAccess = async ({\n    subject,\n    resource,\n    action,\n  }: {\n    subject: Sub;\n    resource: Res;\n    action: Act;\n    context: Ctx;\n  }): Promise<PolicyEvalResult> => {\n    const requiredRoles: Role[] = await requiredRolesResolver(resource, action);\n    const userRoles: Role[] = await userRolesResolver(subject);\n    const hasRole: boolean = requiredRoles.some((role) => userRoles.includes(role));\n    if (hasRole) {\n      return new GrantedAccessResult({\n        policyType: name,\n        reason: 'User has required role',\n      });\n    }\n\n    return new DeniedAccessResult({\n      policyType: name,\n      reason: \"User doesn't have required role\",\n    });\n  };\n\n  return Object.freeze({\n    name: policyType,\n    evaluateAccess,\n    requiredRolesResolver,\n    userRolesResolver,\n  });\n}\n\n/**\n * Interface for attribute-based access control policies.\n *\n * @template Subject - The subject type\n * @template Resource - The resource type\n * @template Action - The action type\n * @template Context - The context type\n */\ninterface AttributeBasedPolicy<Subject, Resource, Action, Context>\n  extends Policy<Subject, Resource, Action, Context> {\n  condition: Condition<Subject, Resource, Action, Context>;\n}\n\n/**\n * Creates an Attribute-Based Access Control policy.\n * Grants access based on attributes of the subject, resource, action, and context.\n *\n * @template Sub - Subject type\n * @template Res - Resource type\n * @template Act - Action type\n * @template Ctx - Context type\n * @param condition Function that evaluates attributes and returns true if access should be granted\n * @returns An ABAC policy\n *\n * @example\n * const abacPolicy = buildAbacPolicy<User, Document, string, Context>(\n *   ({subject, resource}) =>\n *     resource.isPublic || subject.id === resource.ownerId\n * );\n */\nfunction buildAbacPolicy<Sub, Res, Act, Ctx>(\n  {\n    condition,\n    name = 'AbacPolicy',\n  }: {\n    condition: Condition<Sub, Res, Act, Ctx>;\n    name?: string;\n  }\n): AttributeBasedPolicy<Sub, Res, Act, Ctx> {\n  const policyType = name;\n  const evaluateAccess: EvaluateAccess<Sub, Res, Act, Ctx> = async ({\n    subject,\n    resource,\n    action,\n    context,\n  }): Promise<PolicyEvalResult> => {\n    const conditionMet: boolean = await condition({\n      subject,\n      resource,\n      action,\n      context,\n    });\n\n    if (conditionMet) {\n      return new GrantedAccessResult({\n        policyType,\n        reason: 'Condition evaluated to true',\n      });\n    }\n\n    return new DeniedAccessResult({\n      policyType,\n      reason: 'Condition evaluated to false',\n    });\n  };\n\n  return Object.freeze({ name: policyType, evaluateAccess, condition });\n}\n\n/**\n * Function type for resolving relationships between subjects and resources.\n * Used in ReBAC policies to determine if a subject has a specific relationship with a resource.\n *\n * @template Subject - The subject type\n * @template Resource - The resource type\n */\ntype RelationshipResolver<Subject, Resource> = ({\n  subject,\n  resource,\n  relationship,\n}: {\n  subject: Subject;\n  resource: Resource;\n  relationship: string;\n}) => boolean | Promise<boolean>;\n\n/**\n * Interface for relationship-based access control policies.\n *\n * @template Sub - The subject type\n * @template Res - The resource type\n * @template Act - The action type\n * @template Ctx - The context type\n */\ninterface RelationshipBasedPolicy<Sub, Res, Act, Ctx> extends Policy<Sub, Res, Act, Ctx> {\n  readonly relationship: string;\n  readonly resolver: RelationshipResolver<Sub, Res>;\n  name: string;\n}\n\n/**\n * Creates a Relationship-Based Access Control policy.\n * Grants access based on the relationship between subject and resource.\n *\n * @template Sub - Subject type\n * @template Res - Resource type\n * @template Act - Action type\n * @template Ctx - Context type\n * @param relationship Name of the relationship (e.g., \"owner\", \"parent\", \"member\")\n * @param resolver Function that checks if the relationship exists\n * @returns A ReBAC policy\n *\n * @example\n * const ownerPolicy = buildRebacPolicy<User, Document, string, Context>({\n *   relationship: \"owner\",\n *   resolver: ({subject, resource}) => subject.id === resource.ownerId\n * });\n */\nfunction buildRebacPolicy<Sub, Res, Act, Ctx>({\n  relationship,\n  resolver,\n  name = 'RebacPolicy',\n}: {\n  relationship: string;\n  resolver: RelationshipResolver<Sub, Res>;\n  name?: string;\n}): RelationshipBasedPolicy<Sub, Res, Act, Ctx> {\n  const policyType = name;\n  const evaluateAccess: EvaluateAccess<Sub, Res, Act, Ctx> = async ({\n    subject,\n    resource,\n  }): Promise<PolicyEvalResult> => {\n    const hasRelationship: boolean = await resolver({\n      subject,\n      resource,\n      relationship,\n    });\n\n    if (hasRelationship) {\n      return new GrantedAccessResult({\n        policyType,\n        reason: `Subject has ${relationship} relationship with resource`,\n      });\n    }\n\n    return new DeniedAccessResult({\n      policyType,\n      reason: `Subject does not have ${relationship} relationship with resource`,\n    });\n  };\n\n  return Object.freeze({\n    name: policyType,\n    evaluateAccess,\n    resolver,\n    relationship,\n  });\n}\n\n/**\n * Interface for AND combination policies.\n * Requires all child policies to grant access.\n *\n * @template Sub - The subject type\n * @template Res - The resource type\n * @template Act - The action type\n * @template Ctx - The context type\n */\ninterface AndPolicy<Sub, Res, Act, Ctx> extends Policy<Sub, Res, Act, Ctx> {\n  readonly policies: Policy<Sub, Res, Act, Ctx>[];\n  name: string;\n}\n\n/**\n * Creates a policy that requires all sub-policies to grant access.\n *\n * @template Sub - Subject type\n * @template Res - Resource type\n * @template Act - Action type\n * @template Ctx - Context type\n * @param policies Array of policies that all must grant access\n * @returns A combined AND policy\n *\n * @example\n * const policy = buildAndPolicy([adminRolePolicy, documentOwnerPolicy]);\n */\nfunction buildAndPolicy<Sub, Res, Act, Ctx>(\n  {\n    policies,\n    name = 'AndPolicy',\n  }: {\n    policies: Policy<Sub, Res, Act, Ctx>[];\n    name?: string;\n  }\n): AndPolicy<Sub, Res, Act, Ctx> {\n  if (!policies.length) {\n    throw new Error('AndPolicy must have at least one policy');\n  }\n\n  const policyType = name;\n  const evaluateAccess: EvaluateAccess<Sub, Res, Act, Ctx> = async ({\n    subject,\n    resource,\n    action,\n    context,\n  }): Promise<PolicyEvalResult> => {\n    const results: PolicyEvalResult[] = [];\n    for (const policy of policies) {\n      const result = await policy.evaluateAccess({\n        subject,\n        resource,\n        action,\n        context,\n      });\n      results.push(result);\n\n      if (!result.isGranted()) {\n        return new CombinedResult({\n          policyType,\n          outcome: false,\n          operation: CombineOp.And,\n          children: results,\n        });\n      }\n    }\n\n    return new CombinedResult({\n      policyType,\n      outcome: true,\n      operation: CombineOp.And,\n      children: results,\n    });\n  };\n\n  return Object.freeze({\n    name: policyType,\n    evaluateAccess,\n    policies: [...policies],\n  });\n}\n\n/**\n * Interface for OR combination policies.\n * Requires any child policy to grant access.\n *\n * @template Sub - The subject type\n * @template Res - The resource type\n * @template Act - The action type\n * @template Ctx - The context type\n */\ninterface OrPolicy<Sub, Res, Act, Ctx> extends Policy<Sub, Res, Act, Ctx> {\n  readonly policies: Policy<Sub, Res, Act, Ctx>[];\n  name: string;\n}\n\n/**\n * Creates a policy that grants access if any sub-policy grants access.\n *\n * @template Sub - Subject type\n * @template Res - Resource type\n * @template Act - Action type\n * @template Ctx - Context type\n * @param policies Array of policies where any one can grant access\n * @returns A combined OR policy\n *\n * @example\n * const policy = buildOrPolicy([adminRolePolicy, documentOwnerPolicy]);\n */\nfunction buildOrPolicy<Sub, Res, Act, Ctx>(\n  {\n    policies,\n    name = 'OrPolicy',\n  }: {\n    policies: Policy<Sub, Res, Act, Ctx>[];\n    name?: string;\n  }\n): OrPolicy<Sub, Res, Act, Ctx> {\n  if (!policies.length) {\n    throw new Error('OrPolicy must have at least one policy');\n  }\n\n  const policyType = name;\n  const evaluateAccess: EvaluateAccess<Sub, Res, Act, Ctx> = async ({\n    subject,\n    resource,\n    action,\n    context,\n  }): Promise<PolicyEvalResult> => {\n    const results: PolicyEvalResult[] = [];\n    for (const policy of policies) {\n      const result = await policy.evaluateAccess({\n        subject,\n        resource,\n        action,\n        context,\n      });\n      results.push(result);\n\n      if (result.isGranted()) {\n        return new CombinedResult({\n          policyType,\n          outcome: true,\n          operation: CombineOp.Or,\n          children: results,\n        });\n      }\n    }\n\n    return new CombinedResult({\n      policyType,\n      outcome: false,\n      operation: CombineOp.Or,\n      children: results,\n    });\n  };\n\n  return Object.freeze({\n    name: policyType,\n    evaluateAccess,\n    policies: [...policies],\n  });\n}\n\n/**\n * Interface for NOT policies that invert another policy's result.\n *\n * @template Sub - The subject type\n * @template Res - The resource type\n * @template Act - The action type\n * @template Ctx - The context type\n */\ninterface NotPolicy<Sub, Res, Act, Ctx> extends Policy<Sub, Res, Act, Ctx> {\n  readonly policy: Policy<Sub, Res, Act, Ctx>;\n  name: string;\n}\n\n/**\n * Creates a policy that inverts the result of another policy.\n *\n * @template Sub - Subject type\n * @template Res - Resource type\n * @template Act - Action type\n * @template Ctx - Context type\n * @param policy The policy to invert\n * @returns A NOT policy that grants access when the original would deny it\n *\n * @example\n * // Grant access to non-public resources\n * const policy = buildNotPolicy(publicResourcePolicy);\n */\nfunction buildNotPolicy<Sub, Res, Act, Ctx>(\n  {\n    policy,\n    name = 'NotPolicy',\n  }: {\n    policy: Policy<Sub, Res, Act, Ctx>;\n    name?: string;\n  }\n): NotPolicy<Sub, Res, Act, Ctx> {\n  const policyType = name;\n  const evaluateAccess: EvaluateAccess<Sub, Res, Act, Ctx> = async ({\n    subject,\n    resource,\n    action,\n    context,\n  }): Promise<PolicyEvalResult> => {\n    const result = await policy.evaluateAccess({\n      subject,\n      resource,\n      action,\n      context,\n    });\n\n    return new CombinedResult({\n      policyType,\n      outcome: !result.isGranted(),\n      operation: CombineOp.Not,\n      children: [result],\n    });\n  };\n\n  return Object.freeze({\n    name: policyType,\n    evaluateAccess,\n    policy,\n  });\n}\n\nexport {\n  buildAbacPolicy,\n  buildAndPolicy,\n  buildNotPolicy,\n  buildOrPolicy,\n  buildRbacPolicy,\n  buildRebacPolicy,\n  CombineOp,\n  Effect,\n  type EvaluateAccess,\n  type IntendedEffect,\n  PermissionChecker,\n  PolicyBuilder,\n  type Policy,\n  type PolicyEvalResult,\n};\n"
    }
  ]
}
