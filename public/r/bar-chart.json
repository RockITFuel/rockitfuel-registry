{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bar-chart",
  "type": "registry:chart",
  "title": "Bar Chart",
  "description": "D3-powered bar chart component with grouped bars, multiple series support, tooltips, and responsive sizing",
  "dependencies": [
    "d3"
  ],
  "registryDependencies": [
    "chart-utils"
  ],
  "files": [
    {
      "path": "components/charts/bar-chart.tsx",
      "type": "registry:chart",
      "content": "import { select } from \"d3\";\nimport {\n  type Component,\n  createEffect,\n  createMemo,\n  For,\n  on,\n  onMount,\n  Show,\n} from \"solid-js\";\nimport {\n  type ChartMargin,\n  calculateDimensions,\n  chartStyles,\n  computeNumericExtent,\n  createAxisGenerator,\n  createBandScale,\n  createColorScale,\n  createLinearScale,\n  defaultColorPalette,\n  getColorFromPalette,\n  getRelativeMousePosition,\n  renderAxis,\n  styleAxis,\n  styleGridLines,\n  useChartTooltip,\n  useResizeObserver,\n} from \"~/lib/charts\";\n\nexport type BarDataPoint = {\n  category: string;\n  value: number;\n  label?: string;\n};\n\nexport type BarSeries = {\n  id: string;\n  name: string;\n  data: BarDataPoint[];\n  color?: string;\n};\n\nexport type BarChartProps = {\n  data: BarSeries[];\n  width?: number;\n  height?: number;\n  margin?: Partial<ChartMargin>;\n  xAxisLabel?: string;\n  yAxisLabel?: string;\n  showGrid?: boolean;\n  showLegend?: boolean;\n  animate?: boolean;\n  barPadding?: number;\n  groupPadding?: number;\n  colors?: readonly string[];\n  class?: string;\n};\n\ntype TooltipContent = {\n  category: string;\n  value: number;\n  seriesName: string;\n  seriesId: string;\n  color: string;\n  label?: string;\n};\n\nexport const BarChart: Component<BarChartProps> = (props) => {\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let containerRef: HTMLDivElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let svgRef: SVGSVGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let xAxisRef: SVGGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let yAxisRef: SVGGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let gridRef: SVGGElement | undefined;\n\n  const tooltip = useChartTooltip<TooltipContent>();\n\n  const containerSize = useResizeObserver(() => containerRef, {\n    debounceMs: 100,\n  });\n\n  const dimensions = createMemo(() => {\n    const width = props.width ?? containerSize().width;\n    const height = props.height ?? containerSize().height ?? 300;\n    return calculateDimensions(width, height, props.margin);\n  });\n\n  const colorScale = createMemo(() => {\n    const seriesIds = props.data.map((s) => s.id);\n    const colors = props.colors ?? defaultColorPalette;\n    return createColorScale(seriesIds, colors);\n  });\n\n  const categories = createMemo(() => {\n    const allCategories = new Set<string>();\n    for (const series of props.data) {\n      for (const point of series.data) {\n        allCategories.add(point.category);\n      }\n    }\n    return Array.from(allCategories);\n  });\n\n  const xScale = createMemo(() => {\n    const { innerWidth } = dimensions();\n    return createBandScale(categories(), [0, innerWidth], {\n      padding: props.groupPadding ?? 0.2,\n    });\n  });\n\n  const xGroupScale = createMemo(() => {\n    const bandwidth = xScale().bandwidth();\n    const seriesIds = props.data.map((s) => s.id);\n    return createBandScale(seriesIds, [0, bandwidth], {\n      padding: props.barPadding ?? 0.1,\n    });\n  });\n\n  const yScale = createMemo(() => {\n    const { innerHeight } = dimensions();\n    const allYValues = props.data.flatMap((s) => s.data.map((d) => d.value));\n    const extent = computeNumericExtent(allYValues, 0.1);\n    const minY = Math.min(0, extent[0]);\n    return createLinearScale([minY, extent[1]], [innerHeight, 0], {\n      nice: true,\n    });\n  });\n\n  const getSeriesColor = (series: BarSeries, index: number): string => {\n    if (series.color) {\n      return series.color;\n    }\n    return (\n      colorScale()(series.id) ??\n      getColorFromPalette(index, props.colors ?? defaultColorPalette)\n    );\n  };\n\n  onMount(() => {\n    if (xAxisRef && yAxisRef) {\n      updateAxes();\n    }\n  });\n\n  const updateAxes = () => {\n    const { innerWidth, innerHeight } = dimensions();\n\n    if (xAxisRef) {\n      const xAxis = createAxisGenerator(\"bottom\", xScale(), {\n        tickCount: categories().length,\n      });\n      renderAxis(xAxisRef, xAxis);\n      styleAxis(xAxisRef);\n    }\n\n    if (yAxisRef) {\n      const yAxis = createAxisGenerator(\"left\", yScale(), {\n        tickCount: Math.floor(innerHeight / 50),\n      });\n      renderAxis(yAxisRef, yAxis);\n      styleAxis(yAxisRef);\n    }\n\n    if (gridRef && props.showGrid !== false) {\n      const gridAxis = createAxisGenerator(\"left\", yScale(), {\n        tickCount: Math.floor(innerHeight / 50),\n        tickSize: -innerWidth,\n      });\n      select(gridRef).call(gridAxis);\n      styleGridLines(gridRef);\n    }\n  };\n\n  createEffect(\n    on([dimensions, xScale, yScale], () => {\n      updateAxes();\n    })\n  );\n\n  const handleMouseMove = (event: MouseEvent) => {\n    if (!svgRef) {\n      return;\n    }\n\n    const { margin } = dimensions();\n    const mousePos = getRelativeMousePosition(event, svgRef);\n    const adjustedX = mousePos.x - margin.left;\n    const adjustedY = mousePos.y - margin.top;\n\n    const closest = findClosestBar(adjustedX, adjustedY);\n\n    if (closest) {\n      tooltip.show(closest, { x: mousePos.x, y: mousePos.y });\n    } else {\n      tooltip.hide();\n    }\n  };\n\n  const findClosestBar = (\n    mouseX: number,\n    mouseY: number\n  ): TooltipContent | null => {\n    const { innerHeight } = dimensions();\n    const xS = xScale();\n    const xGS = xGroupScale();\n    const yS = yScale();\n\n    for (let seriesIndex = 0; seriesIndex < props.data.length; seriesIndex++) {\n      const series = props.data[seriesIndex];\n      for (const point of series.data) {\n        const categoryX = xS(point.category) ?? 0;\n        const barX = categoryX + (xGS(series.id) ?? 0);\n        const barWidth = xGS.bandwidth();\n        const barY = yS(point.value);\n        const barHeight = innerHeight - barY;\n\n        if (\n          mouseX >= barX &&\n          mouseX <= barX + barWidth &&\n          mouseY >= barY &&\n          mouseY <= barY + barHeight\n        ) {\n          return {\n            category: point.category,\n            value: point.value,\n            seriesName: series.name,\n            seriesId: series.id,\n            color: getSeriesColor(series, seriesIndex),\n            label: point.label,\n          };\n        }\n      }\n    }\n\n    return null;\n  };\n\n  const handleMouseLeave = () => {\n    tooltip.hide();\n  };\n\n  const formatTooltipValue = (value: number | undefined): string => {\n    if (value === undefined) {\n      return \"\";\n    }\n    return value.toLocaleString(undefined, {\n      maximumFractionDigits: 2,\n    });\n  };\n\n  return (\n    <div\n      class={`relative w-full ${props.class ?? \"\"}`}\n      ref={containerRef}\n      style={{ \"min-height\": `${props.height ?? 300}px` }}\n    >\n      <Show when={dimensions().width > 0 && dimensions().height > 0}>\n        {/* biome-ignore lint/a11y/noSvgWithoutTitle: Chart with programmatic tooltip */}\n        {/* biome-ignore lint/a11y/noNoninteractiveElementInteractions: Chart interaction */}\n        <svg\n          class=\"select-none\"\n          height={dimensions().height}\n          onMouseLeave={handleMouseLeave}\n          onMouseMove={handleMouseMove}\n          ref={svgRef}\n          width={dimensions().width}\n        >\n          <g\n            transform={`translate(${dimensions().margin.left},${dimensions().margin.top})`}\n          >\n            <Show when={props.showGrid !== false}>\n              <g class=\"grid\" ref={gridRef} />\n            </Show>\n\n            <For each={props.data}>\n              {(series, seriesIndex) => {\n                const color = () => getSeriesColor(series, seriesIndex());\n\n                return (\n                  <g class=\"series\">\n                    <For each={series.data}>\n                      {(point) => {\n                        const barX = () => {\n                          const categoryX = xScale()(point.category) ?? 0;\n                          const groupOffset = xGroupScale()(series.id) ?? 0;\n                          return categoryX + groupOffset;\n                        };\n                        const barY = () => yScale()(point.value);\n                        const barWidth = () => xGroupScale().bandwidth();\n                        const barHeight = () =>\n                          dimensions().innerHeight - yScale()(point.value);\n\n                        return (\n                          <rect\n                            fill={color()}\n                            height={Math.max(0, barHeight())}\n                            rx={2}\n                            ry={2}\n                            width={barWidth()}\n                            x={barX()}\n                            y={barY()}\n                          />\n                        );\n                      }}\n                    </For>\n                  </g>\n                );\n              }}\n            </For>\n\n            <g\n              class=\"x-axis\"\n              ref={xAxisRef}\n              transform={`translate(0,${dimensions().innerHeight})`}\n            />\n            <g class=\"y-axis\" ref={yAxisRef} />\n\n            <Show when={props.xAxisLabel}>\n              <text\n                fill={chartStyles.axis.text}\n                font-size={chartStyles.axis.fontSize}\n                text-anchor=\"middle\"\n                x={dimensions().innerWidth / 2}\n                y={dimensions().innerHeight + dimensions().margin.bottom - 5}\n              >\n                {props.xAxisLabel}\n              </text>\n            </Show>\n\n            <Show when={props.yAxisLabel}>\n              <text\n                fill={chartStyles.axis.text}\n                font-size={chartStyles.axis.fontSize}\n                text-anchor=\"middle\"\n                transform=\"rotate(-90)\"\n                x={-dimensions().innerHeight / 2}\n                y={-dimensions().margin.left + 15}\n              >\n                {props.yAxisLabel}\n              </text>\n            </Show>\n          </g>\n        </svg>\n\n        <Show when={props.showLegend !== false && props.data.length > 1}>\n          <div class=\"mt-4 flex flex-wrap justify-center gap-4\">\n            <For each={props.data}>\n              {(series, index) => (\n                <div class=\"flex items-center gap-2\">\n                  <span\n                    class=\"h-3 w-3 rounded-full\"\n                    style={{ background: getSeriesColor(series, index()) }}\n                  />\n                  <span class=\"text-muted-foreground text-sm\">\n                    {series.name}\n                  </span>\n                </div>\n              )}\n            </For>\n          </div>\n        </Show>\n\n        <Show when={tooltip.isVisible()}>\n          <div\n            class=\"pointer-events-none absolute z-50 rounded-md border px-3 py-2 shadow-md\"\n            style={{\n              left: `${tooltip.state().position.x + 10}px`,\n              top: `${tooltip.state().position.y + 10}px`,\n              background: chartStyles.tooltip.background,\n              border: `1px solid ${chartStyles.tooltip.border}`,\n              color: chartStyles.tooltip.text,\n              \"box-shadow\": chartStyles.tooltip.shadow,\n            }}\n          >\n            <div class=\"flex items-center gap-2\">\n              <span\n                class=\"h-2 w-2 rounded-full\"\n                style={{ background: tooltip.state().data?.color }}\n              />\n              <span class=\"font-medium\">\n                {tooltip.state().data?.seriesName}\n              </span>\n            </div>\n            <div class=\"mt-1 text-muted-foreground text-sm\">\n              <div>{tooltip.state().data?.category}</div>\n              <div class=\"font-medium text-foreground\">\n                {formatTooltipValue(tooltip.state().data?.value)}\n              </div>\n              <Show when={tooltip.state().data?.label}>\n                <div class=\"text-xs\">{tooltip.state().data?.label}</div>\n              </Show>\n            </div>\n          </div>\n        </Show>\n      </Show>\n    </div>\n  );\n};\n\nexport default BarChart;\n"
    }
  ]
}
