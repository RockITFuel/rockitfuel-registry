{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "chart-utils",
  "type": "registry:lib",
  "title": "Chart Utilities",
  "description": "Core D3 chart utilities including scales, axes, tooltips, theming, and responsive sizing for SolidJS",
  "dependencies": [
    "d3"
  ],
  "files": [
    {
      "path": "lib/charts/types.ts",
      "type": "registry:lib",
      "content": "import type {\n  ScaleBand,\n  ScaleLinear,\n  ScaleOrdinal,\n  ScalePoint,\n  ScaleTime,\n} from \"d3\";\n\n/**\n * Chart margin configuration\n */\nexport type ChartMargin = {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n};\n\n/**\n * Chart dimensions including margins\n */\nexport type ChartDimensions = {\n  width: number;\n  height: number;\n  margin: ChartMargin;\n  innerWidth: number;\n  innerHeight: number;\n};\n\n/**\n * Common data point structure\n */\nexport type DataPoint = {\n  x: number | string | Date;\n  y: number;\n  label?: string;\n};\n\n/**\n * Time series data point\n */\nexport type TimeSeriesPoint = {\n  date: Date;\n  value: number;\n  label?: string;\n};\n\n/**\n * Category data point for bar/pie charts\n */\nexport type CategoryPoint = {\n  category: string;\n  value: number;\n  color?: string;\n};\n\n/**\n * Scale types supported by the utilities\n */\nexport type LinearScale = ScaleLinear<number, number>;\nexport type TimeScale = ScaleTime<number, number>;\nexport type BandScale = ScaleBand<string>;\nexport type OrdinalScale<T> = ScaleOrdinal<string, T>;\nexport type PointScale = ScalePoint<string>;\n\n/**\n * Axis orientation\n */\nexport type AxisOrientation = \"top\" | \"right\" | \"bottom\" | \"left\";\n\n/**\n * Axis configuration\n */\nexport type AxisConfig = {\n  orientation: AxisOrientation;\n  tickCount?: number;\n  tickFormat?: (value: unknown) => string;\n  tickSize?: number;\n  tickPadding?: number;\n  label?: string;\n  labelOffset?: number;\n};\n\n/**\n * Tooltip data for chart interactions\n */\nexport type TooltipData<T = unknown> = {\n  x: number;\n  y: number;\n  data: T;\n  visible: boolean;\n};\n\n/**\n * Chart theme colors derived from CSS variables\n */\nexport type ChartTheme = {\n  primary: string;\n  secondary: string;\n  foreground: string;\n  muted: string;\n  mutedForeground: string;\n  background: string;\n  border: string;\n  accent: string;\n  destructive: string;\n  success: string;\n  warning: string;\n  info: string;\n};\n\n/**\n * Default chart color palette\n */\nexport type ChartColorPalette = readonly string[];\n"
    },
    {
      "path": "lib/charts/scales.ts",
      "type": "registry:lib",
      "content": "import {\n  extent,\n  scaleBand,\n  scaleLinear,\n  scaleOrdinal,\n  scalePoint,\n  scaleTime,\n} from \"d3\";\nimport type {\n  BandScale,\n  ChartDimensions,\n  LinearScale,\n  PointScale,\n  TimeScale,\n} from \"./types\";\n\n/**\n * Create a linear scale for numeric data\n */\nexport function createLinearScale(\n  domain: [number, number],\n  range: [number, number],\n  options?: {\n    nice?: boolean;\n    clamp?: boolean;\n  }\n): LinearScale {\n  const scale = scaleLinear().domain(domain).range(range);\n\n  if (options?.nice) {\n    scale.nice();\n  }\n\n  if (options?.clamp) {\n    scale.clamp(true);\n  }\n\n  return scale;\n}\n\n/**\n * Create a time scale for date/time data\n */\nexport function createTimeScale(\n  domain: [Date, Date],\n  range: [number, number],\n  options?: {\n    nice?: boolean;\n    clamp?: boolean;\n  }\n): TimeScale {\n  const scale = scaleTime().domain(domain).range(range);\n\n  if (options?.nice) {\n    scale.nice();\n  }\n\n  if (options?.clamp) {\n    scale.clamp(true);\n  }\n\n  return scale;\n}\n\n/**\n * Create a band scale for categorical data (bar charts)\n */\nexport function createBandScale(\n  domain: string[],\n  range: [number, number],\n  options?: {\n    padding?: number;\n    paddingInner?: number;\n    paddingOuter?: number;\n    align?: number;\n  }\n): BandScale {\n  const scale = scaleBand().domain(domain).range(range);\n\n  if (options?.padding !== undefined) {\n    scale.padding(options.padding);\n  }\n\n  if (options?.paddingInner !== undefined) {\n    scale.paddingInner(options.paddingInner);\n  }\n\n  if (options?.paddingOuter !== undefined) {\n    scale.paddingOuter(options.paddingOuter);\n  }\n\n  if (options?.align !== undefined) {\n    scale.align(options.align);\n  }\n\n  return scale;\n}\n\n/**\n * Create a point scale for categorical data (scatter/line charts)\n */\nexport function createPointScale(\n  domain: string[],\n  range: [number, number],\n  options?: {\n    padding?: number;\n    align?: number;\n  }\n): PointScale {\n  const scale = scalePoint().domain(domain).range(range);\n\n  if (options?.padding !== undefined) {\n    scale.padding(options.padding);\n  }\n\n  if (options?.align !== undefined) {\n    scale.align(options.align);\n  }\n\n  return scale;\n}\n\n/**\n * Create a color scale from a domain to a color range\n */\nexport function createColorScale<T extends string>(\n  domain: string[],\n  colors: readonly T[]\n): ReturnType<typeof scaleOrdinal<string, T>> {\n  return scaleOrdinal<string, T>()\n    .domain(domain)\n    .range([...colors] as T[]);\n}\n\n/**\n * Calculate chart dimensions from container size and margins\n */\nexport function calculateDimensions(\n  width: number,\n  height: number,\n  margin: Partial<{\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n  }> = {}\n): ChartDimensions {\n  const defaultMargin = {\n    top: margin.top ?? 20,\n    right: margin.right ?? 20,\n    bottom: margin.bottom ?? 40,\n    left: margin.left ?? 50,\n  };\n\n  return {\n    width,\n    height,\n    margin: defaultMargin,\n    innerWidth: Math.max(0, width - defaultMargin.left - defaultMargin.right),\n    innerHeight: Math.max(0, height - defaultMargin.top - defaultMargin.bottom),\n  };\n}\n\n/**\n * Compute domain extent for numeric data with optional padding\n */\nexport function computeNumericExtent(\n  data: number[],\n  padding = 0\n): [number, number] {\n  const dataExtent = extent(data) as [number, number];\n  if (padding === 0) {\n    return dataExtent;\n  }\n\n  const range = dataExtent[1] - dataExtent[0];\n  return [dataExtent[0] - range * padding, dataExtent[1] + range * padding];\n}\n\n/**\n * Compute domain extent for time data\n */\nexport function computeTimeExtent(data: Date[]): [Date, Date] {\n  return extent(data) as [Date, Date];\n}\n\n/**\n * Get nice tick values for a linear scale\n */\nexport function getNiceTickValues(scale: LinearScale, count = 5): number[] {\n  return scale.ticks(count);\n}\n\n/**\n * Get nice tick values for a time scale\n */\nexport function getNiceTimeTickValues(scale: TimeScale, count = 5): Date[] {\n  return scale.ticks(count);\n}\n"
    },
    {
      "path": "lib/charts/axis.ts",
      "type": "registry:lib",
      "content": "import {\n  type Axis,\n  type AxisDomain,\n  type AxisScale,\n  axisBottom,\n  axisLeft,\n  axisRight,\n  axisTop,\n  format,\n  select,\n  timeFormat,\n} from \"d3\";\nimport type {\n  AxisOrientation,\n  BandScale,\n  LinearScale,\n  TimeScale,\n} from \"./types\";\n\ntype AnyScale = LinearScale | TimeScale | BandScale;\n\ntype AxisOptions = {\n  tickCount?: number;\n  tickFormat?: (value: unknown) => string;\n  tickSize?: number;\n  tickSizeInner?: number;\n  tickSizeOuter?: number;\n  tickPadding?: number;\n  tickValues?: unknown[];\n};\n\n/**\n * Create a D3 axis generator for the given orientation and scale\n */\nexport function createAxisGenerator<S extends AnyScale>(\n  orientation: AxisOrientation,\n  scale: S,\n  options: AxisOptions = {}\n): Axis<AxisDomain> {\n  const axisGenerators = {\n    top: axisTop,\n    right: axisRight,\n    bottom: axisBottom,\n    left: axisLeft,\n  };\n\n  const axis = axisGenerators[orientation](scale as AxisScale<AxisDomain>);\n\n  if (options.tickCount !== undefined) {\n    axis.ticks(options.tickCount);\n  }\n\n  if (options.tickFormat !== undefined) {\n    axis.tickFormat(options.tickFormat as (domainValue: AxisDomain) => string);\n  }\n\n  if (options.tickSize !== undefined) {\n    axis.tickSize(options.tickSize);\n  }\n\n  if (options.tickSizeInner !== undefined) {\n    axis.tickSizeInner(options.tickSizeInner);\n  }\n\n  if (options.tickSizeOuter !== undefined) {\n    axis.tickSizeOuter(options.tickSizeOuter);\n  }\n\n  if (options.tickPadding !== undefined) {\n    axis.tickPadding(options.tickPadding);\n  }\n\n  if (options.tickValues !== undefined) {\n    axis.tickValues(options.tickValues as AxisDomain[]);\n  }\n\n  return axis;\n}\n\n/**\n * Render an axis to an SVG group element\n */\nexport function renderAxis(\n  container: SVGGElement,\n  axis: Axis<AxisDomain>,\n  options?: {\n    animate?: boolean;\n    duration?: number;\n  }\n): void {\n  const selection = select(container);\n\n  if (options?.animate) {\n    selection\n      .transition()\n      .duration(options.duration ?? 300)\n      .call(axis);\n  } else {\n    selection.call(axis);\n  }\n}\n\n/**\n * Apply theme-aware styling to axis elements\n */\nexport function styleAxis(\n  container: SVGGElement,\n  options?: {\n    lineColor?: string;\n    textColor?: string;\n    fontSize?: string;\n    fontFamily?: string;\n  }\n): void {\n  const selection = select(container);\n\n  // Style the axis line and ticks\n  selection\n    .selectAll(\"line, path\")\n    .attr(\"stroke\", options?.lineColor ?? \"hsl(var(--border))\");\n\n  // Style the tick text\n  selection\n    .selectAll(\"text\")\n    .attr(\"fill\", options?.textColor ?? \"hsl(var(--muted-foreground))\")\n    .attr(\"font-size\", options?.fontSize ?? \"12px\")\n    .attr(\"font-family\", options?.fontFamily ?? \"inherit\");\n}\n\n/**\n * Create a grid line generator for the given orientation\n */\nexport function createGridLines<S extends AnyScale>(\n  orientation: \"horizontal\" | \"vertical\",\n  scale: S,\n  size: number,\n  options?: {\n    tickCount?: number;\n    tickValues?: unknown[];\n  }\n): Axis<AxisDomain> {\n  const axis =\n    orientation === \"horizontal\"\n      ? axisLeft(scale as AxisScale<AxisDomain>).tickSize(-size)\n      : axisBottom(scale as AxisScale<AxisDomain>).tickSize(-size);\n\n  axis.tickFormat(() => \"\");\n\n  if (options?.tickCount !== undefined) {\n    axis.ticks(options.tickCount);\n  }\n\n  if (options?.tickValues !== undefined) {\n    axis.tickValues(options.tickValues as AxisDomain[]);\n  }\n\n  return axis;\n}\n\n/**\n * Apply styling to grid lines\n */\nexport function styleGridLines(\n  container: SVGGElement,\n  options?: {\n    color?: string;\n    opacity?: number;\n    dashArray?: string;\n  }\n): void {\n  const selection = select(container);\n\n  selection\n    .selectAll(\"line\")\n    .attr(\"stroke\", options?.color ?? \"hsl(var(--border))\")\n    .attr(\"stroke-opacity\", options?.opacity ?? 0.5)\n    .attr(\"stroke-dasharray\", options?.dashArray ?? \"\");\n\n  // Hide the domain line\n  selection.select(\".domain\").attr(\"stroke\", \"none\");\n}\n\n/**\n * Get recommended tick format for different data types\n */\nexport function getTickFormat(\n  type: \"number\" | \"currency\" | \"percent\" | \"date\" | \"shortDate\" | \"time\"\n): (value: unknown) => string {\n  switch (type) {\n    case \"number\":\n      return (v) => format(\",.0f\")(v as number);\n    case \"currency\":\n      return (v) => format(\"$,.2f\")(v as number);\n    case \"percent\":\n      return (v) => format(\".0%\")(v as number);\n    case \"date\":\n      return (v) => timeFormat(\"%b %d, %Y\")(v as Date);\n    case \"shortDate\":\n      return (v) => timeFormat(\"%b %d\")(v as Date);\n    case \"time\":\n      return (v) => timeFormat(\"%H:%M\")(v as Date);\n    default:\n      return String;\n  }\n}\n"
    },
    {
      "path": "lib/charts/tooltip.ts",
      "type": "registry:lib",
      "content": "import type { Accessor } from \"solid-js\";\nimport { createSignal } from \"solid-js\";\n\ntype TooltipPosition = {\n  x: number;\n  y: number;\n};\n\ntype TooltipState<T> = {\n  visible: boolean;\n  position: TooltipPosition;\n  data: T | null;\n};\n\ntype UseChartTooltipReturn<T> = {\n  state: Accessor<TooltipState<T>>;\n  show: (data: T, position: TooltipPosition) => void;\n  hide: () => void;\n  updatePosition: (position: TooltipPosition) => void;\n  isVisible: Accessor<boolean>;\n};\n\n/**\n * Create a reactive tooltip state for chart interactions\n */\nexport function useChartTooltip<T>(): UseChartTooltipReturn<T> {\n  const [state, setState] = createSignal<TooltipState<T>>({\n    visible: false,\n    position: { x: 0, y: 0 },\n    data: null,\n  });\n\n  const show = (data: T, position: TooltipPosition) => {\n    setState({\n      visible: true,\n      position,\n      data,\n    });\n  };\n\n  const hide = () => {\n    setState((prev) => ({\n      ...prev,\n      visible: false,\n    }));\n  };\n\n  const updatePosition = (position: TooltipPosition) => {\n    setState((prev) => ({\n      ...prev,\n      position,\n    }));\n  };\n\n  const isVisible = () => state().visible;\n\n  return {\n    state,\n    show,\n    hide,\n    updatePosition,\n    isVisible,\n  };\n}\n\ntype TooltipPositionOptions = {\n  mouseX: number;\n  mouseY: number;\n  tooltipWidth: number;\n  tooltipHeight: number;\n  containerBounds: DOMRect;\n  offsetX?: number;\n  offsetY?: number;\n};\n\n/**\n * Calculate optimal tooltip position to keep it within bounds\n */\nexport function calculateTooltipPosition(\n  options: TooltipPositionOptions\n): TooltipPosition {\n  const {\n    mouseX,\n    mouseY,\n    tooltipWidth,\n    tooltipHeight,\n    containerBounds,\n    offsetX = 10,\n    offsetY = 10,\n  } = options;\n\n  let x = mouseX + offsetX;\n  let y = mouseY + offsetY;\n\n  // Adjust horizontal position if tooltip would overflow right\n  if (x + tooltipWidth > containerBounds.width) {\n    x = mouseX - tooltipWidth - offsetX;\n  }\n\n  // Adjust horizontal position if tooltip would overflow left\n  if (x < 0) {\n    x = offsetX;\n  }\n\n  // Adjust vertical position if tooltip would overflow bottom\n  if (y + tooltipHeight > containerBounds.height) {\n    y = mouseY - tooltipHeight - offsetY;\n  }\n\n  // Adjust vertical position if tooltip would overflow top\n  if (y < 0) {\n    y = offsetY;\n  }\n\n  return { x, y };\n}\n\n/**\n * Get the mouse position relative to an SVG element\n */\nexport function getRelativeMousePosition(\n  event: MouseEvent,\n  svgElement: SVGSVGElement\n): TooltipPosition {\n  const rect = svgElement.getBoundingClientRect();\n  return {\n    x: event.clientX - rect.left,\n    y: event.clientY - rect.top,\n  };\n}\n\n/**\n * Find the closest data point to the mouse position\n */\nexport function findClosestPoint<T extends { x: number; y: number }>(\n  points: T[],\n  mouseX: number,\n  mouseY: number,\n  threshold = 50\n): T | null {\n  let closest: T | null = null;\n  let minDistance = threshold;\n\n  for (const point of points) {\n    const distance = Math.sqrt(\n      (point.x - mouseX) ** 2 + (point.y - mouseY) ** 2\n    );\n    if (distance < minDistance) {\n      minDistance = distance;\n      closest = point;\n    }\n  }\n\n  return closest;\n}\n\n/**\n * Find the closest data point on the x-axis (for line/area charts)\n */\nexport function findClosestPointByX<T extends { x: number }>(\n  points: T[],\n  mouseX: number\n): T | null {\n  if (points.length === 0) {\n    return null;\n  }\n\n  let closest = points[0];\n  let minDistance = Math.abs(points[0].x - mouseX);\n\n  for (const point of points) {\n    const distance = Math.abs(point.x - mouseX);\n    if (distance < minDistance) {\n      minDistance = distance;\n      closest = point;\n    }\n  }\n\n  return closest;\n}\n\n/**\n * Bisect to find the index of the closest point (for sorted data)\n */\nexport function bisectIndex<T>(\n  data: T[],\n  x: number,\n  accessor: (d: T) => number\n): number {\n  let lo = 0;\n  let hi = data.length;\n\n  while (lo < hi) {\n    // biome-ignore lint/suspicious/noBitwiseOperators: efficient integer division\n    const mid = (lo + hi) >>> 1;\n    if (accessor(data[mid]) < x) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n\n  // Return the closer of the two adjacent points\n  if (lo > 0 && lo < data.length) {\n    const d0 = x - accessor(data[lo - 1]);\n    const d1 = accessor(data[lo]) - x;\n    return d1 < d0 ? lo : lo - 1;\n  }\n\n  return Math.max(0, Math.min(data.length - 1, lo));\n}\n"
    },
    {
      "path": "lib/charts/resize.ts",
      "type": "registry:lib",
      "content": "import type { Accessor } from \"solid-js\";\nimport { createSignal, onCleanup, onMount } from \"solid-js\";\nimport { calculateDimensions } from \"./scales\";\nimport type { ChartDimensions, ChartMargin } from \"./types\";\n\ntype UseResizeObserverOptions = {\n  debounceMs?: number;\n};\n\ntype ContainerSize = {\n  width: number;\n  height: number;\n};\n\n/**\n * Hook to observe container size changes with optional debounce\n */\nexport function useResizeObserver(\n  containerRef: () => HTMLElement | null | undefined,\n  options?: UseResizeObserverOptions\n): Accessor<ContainerSize> {\n  const [size, setSize] = createSignal<ContainerSize>({ width: 0, height: 0 });\n  let resizeObserver: ResizeObserver | null = null;\n  let debounceTimeout: ReturnType<typeof setTimeout> | null = null;\n\n  const updateSize = (entries: ResizeObserverEntry[]) => {\n    const entry = entries[0];\n    if (!entry) {\n      return;\n    }\n\n    const { width, height } = entry.contentRect;\n\n    if (options?.debounceMs) {\n      if (debounceTimeout) {\n        clearTimeout(debounceTimeout);\n      }\n      debounceTimeout = setTimeout(() => {\n        setSize({ width, height });\n      }, options.debounceMs);\n    } else {\n      setSize({ width, height });\n    }\n  };\n\n  onMount(() => {\n    const container = containerRef();\n    if (!container) {\n      return;\n    }\n\n    // Initial size\n    const rect = container.getBoundingClientRect();\n    setSize({ width: rect.width, height: rect.height });\n\n    // Create observer\n    resizeObserver = new ResizeObserver(updateSize);\n    resizeObserver.observe(container);\n  });\n\n  onCleanup(() => {\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n    }\n    if (debounceTimeout) {\n      clearTimeout(debounceTimeout);\n    }\n  });\n\n  return size;\n}\n\n/**\n * Hook that provides reactive chart dimensions based on container size\n */\nexport function useChartDimensions(\n  containerRef: () => HTMLElement | null | undefined,\n  margin?: Partial<ChartMargin>,\n  options?: UseResizeObserverOptions\n): Accessor<ChartDimensions> {\n  const size = useResizeObserver(containerRef, options);\n\n  return () => calculateDimensions(size().width, size().height, margin);\n}\n\n/**\n * Get device pixel ratio for crisp rendering on high-DPI displays\n */\nexport function getDevicePixelRatio(): number {\n  return typeof window !== \"undefined\" ? window.devicePixelRatio || 1 : 1;\n}\n\n/**\n * Scale canvas for high-DPI displays\n */\nexport function scaleCanvas(\n  canvas: HTMLCanvasElement,\n  ctx: CanvasRenderingContext2D,\n  width: number,\n  height: number\n): void {\n  const dpr = getDevicePixelRatio();\n\n  canvas.width = width * dpr;\n  canvas.height = height * dpr;\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n\n  ctx.scale(dpr, dpr);\n}\n\n/**\n * Set SVG viewBox for responsive sizing\n */\nexport function setSvgViewBox(\n  svg: SVGSVGElement,\n  width: number,\n  height: number\n): void {\n  svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svg.setAttribute(\"preserveAspectRatio\", \"xMidYMid meet\");\n}\n\n/**\n * Get the bounding rect of an SVG element relative to its container\n */\nexport function getElementBounds(element: Element): DOMRect {\n  return element.getBoundingClientRect();\n}\n\n/**\n * Check if an element is visible in the viewport\n */\nexport function isElementVisible(element: Element): boolean {\n  const rect = element.getBoundingClientRect();\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <=\n      (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n"
    },
    {
      "path": "lib/charts/theme.ts",
      "type": "registry:lib",
      "content": "import type { ChartColorPalette, ChartTheme } from \"./types\";\n\n/**\n * CSS variable to HSL value converter\n */\nfunction cssVarToHsl(varName: string): string {\n  return `hsl(var(${varName}))`;\n}\n\n/**\n * Get computed CSS variable value from the document\n */\nexport function getCssVariable(varName: string): string {\n  if (typeof document === \"undefined\") {\n    return \"\";\n  }\n  return getComputedStyle(document.documentElement)\n    .getPropertyValue(varName)\n    .trim();\n}\n\n/**\n * Check if dark mode is active\n */\nexport function isDarkMode(): boolean {\n  if (typeof document === \"undefined\") {\n    return false;\n  }\n  return (\n    document.documentElement.classList.contains(\"dark\") ||\n    document.documentElement.getAttribute(\"data-kb-theme\") === \"dark\"\n  );\n}\n\n/**\n * Get chart theme colors from CSS variables\n */\nexport function getChartTheme(): ChartTheme {\n  return {\n    primary: cssVarToHsl(\"--primary\"),\n    secondary: cssVarToHsl(\"--secondary\"),\n    foreground: cssVarToHsl(\"--foreground\"),\n    muted: cssVarToHsl(\"--muted\"),\n    mutedForeground: cssVarToHsl(\"--muted-foreground\"),\n    background: cssVarToHsl(\"--background\"),\n    border: cssVarToHsl(\"--border\"),\n    accent: cssVarToHsl(\"--accent\"),\n    destructive: cssVarToHsl(\"--destructive\"),\n    success: cssVarToHsl(\"--success-foreground\"),\n    warning: cssVarToHsl(\"--warning-foreground\"),\n    info: cssVarToHsl(\"--info-foreground\"),\n  };\n}\n\n/**\n * Default chart color palette using theme-aware colors\n */\nexport const defaultColorPalette: ChartColorPalette = [\n  \"hsl(var(--primary))\",\n  \"hsl(var(--info-foreground))\",\n  \"hsl(var(--success-foreground))\",\n  \"hsl(var(--warning-foreground))\",\n  \"hsl(var(--destructive))\",\n  \"hsl(var(--accent-foreground))\",\n  \"hsl(var(--muted-foreground))\",\n] as const;\n\n/**\n * Extended color palette for charts with many categories\n */\nexport const extendedColorPalette: ChartColorPalette = [\n  \"hsl(var(--primary))\",\n  \"hsl(var(--info-foreground))\",\n  \"hsl(var(--success-foreground))\",\n  \"hsl(var(--warning-foreground))\",\n  \"hsl(var(--destructive))\",\n  \"hsl(220, 70%, 50%)\", // Blue\n  \"hsl(280, 65%, 60%)\", // Purple\n  \"hsl(340, 75%, 55%)\", // Pink\n  \"hsl(170, 60%, 45%)\", // Teal\n  \"hsl(30, 80%, 55%)\", // Orange\n] as const;\n\n/**\n * Categorical color palette (colorblind-friendly)\n */\nexport const categoricalPalette: ChartColorPalette = [\n  \"#2271B3\", // Blue\n  \"#D55E00\", // Vermillion\n  \"#009E73\", // Bluish green\n  \"#CC79A7\", // Reddish purple\n  \"#F0E442\", // Yellow\n  \"#56B4E9\", // Sky blue\n  \"#E69F00\", // Orange\n  \"#0072B2\", // Blue\n] as const;\n\n/**\n * Sequential color palette for gradients\n */\nexport const sequentialPalette: ChartColorPalette = [\n  \"hsl(var(--primary) / 0.1)\",\n  \"hsl(var(--primary) / 0.3)\",\n  \"hsl(var(--primary) / 0.5)\",\n  \"hsl(var(--primary) / 0.7)\",\n  \"hsl(var(--primary) / 0.9)\",\n  \"hsl(var(--primary))\",\n] as const;\n\n/**\n * Diverging color palette for data with a midpoint\n */\nexport const divergingPalette: ChartColorPalette = [\n  \"hsl(var(--destructive))\",\n  \"hsl(var(--destructive) / 0.7)\",\n  \"hsl(var(--destructive) / 0.4)\",\n  \"hsl(var(--muted))\",\n  \"hsl(var(--success-foreground) / 0.4)\",\n  \"hsl(var(--success-foreground) / 0.7)\",\n  \"hsl(var(--success-foreground))\",\n] as const;\n\n/**\n * Get a color from a palette by index (cycles if index exceeds length)\n */\nexport function getColorFromPalette(\n  index: number,\n  palette: ChartColorPalette = defaultColorPalette\n): string {\n  return palette[index % palette.length];\n}\n\n// Top-level regex for performance\nconst HSL_VAR_REGEX = /hsl\\(var\\((--[^)]+)\\)\\)/;\n\n/**\n * Generate a color with opacity\n */\nexport function withOpacity(color: string, opacity: number): string {\n  // Handle HSL CSS variables\n  if (color.startsWith(\"hsl(var(\")) {\n    const varMatch = color.match(HSL_VAR_REGEX);\n    if (varMatch) {\n      return `hsl(var(${varMatch[1]}) / ${opacity})`;\n    }\n  }\n  // Handle regular HSL\n  if (color.startsWith(\"hsl(\")) {\n    return color.replace(\")\", ` / ${opacity})`).replace(\"hsl(\", \"hsla(\");\n  }\n  // Handle hex colors\n  if (color.startsWith(\"#\")) {\n    const alpha = Math.round(opacity * 255)\n      .toString(16)\n      .padStart(2, \"0\");\n    return `${color}${alpha}`;\n  }\n  return color;\n}\n\n/**\n * Chart styling presets\n */\nexport const chartStyles = {\n  axis: {\n    line: \"hsl(var(--border))\",\n    text: \"hsl(var(--muted-foreground))\",\n    fontSize: \"12px\",\n  },\n  grid: {\n    line: \"hsl(var(--border))\",\n    opacity: 0.5,\n  },\n  tooltip: {\n    background: \"hsl(var(--popover))\",\n    border: \"hsl(var(--border))\",\n    text: \"hsl(var(--popover-foreground))\",\n    shadow: \"0 4px 6px -1px rgb(0 0 0 / 0.1)\",\n  },\n  animation: {\n    duration: 300,\n    easing: \"ease-out\",\n  },\n} as const;\n"
    },
    {
      "path": "lib/charts/format.ts",
      "type": "registry:lib",
      "content": "import { format, isoFormat, isoParse, timeFormat, timeParse } from \"d3\";\n\n/**\n * Format a number with SI prefix (k, M, G, etc.)\n */\nexport function formatSI(value: number, precision = 2): string {\n  return format(`.${precision}s`)(value);\n}\n\n/**\n * Format a number with commas as thousands separator\n */\nexport function formatNumber(value: number, decimals = 0): string {\n  return format(`,.${decimals}f`)(value);\n}\n\n/**\n * Format a number as currency\n */\nexport function formatCurrency(\n  value: number,\n  currency = \"$\",\n  decimals = 2\n): string {\n  return `${currency}${format(`,.${decimals}f`)(value)}`;\n}\n\n/**\n * Format a number as a percentage\n */\nexport function formatPercent(value: number, decimals = 1): string {\n  return format(`.${decimals}%`)(value);\n}\n\n/**\n * Format a date with a specified format string\n */\nexport function formatDate(date: Date, formatStr = \"%b %d, %Y\"): string {\n  return timeFormat(formatStr)(date);\n}\n\n/**\n * Format a date as a short date (e.g., \"Jan 1\")\n */\nexport function formatShortDate(date: Date): string {\n  return timeFormat(\"%b %d\")(date);\n}\n\n/**\n * Format a date as a full date (e.g., \"January 1, 2024\")\n */\nexport function formatFullDate(date: Date): string {\n  return timeFormat(\"%B %d, %Y\")(date);\n}\n\n/**\n * Format a date as time (e.g., \"14:30\")\n */\nexport function formatTime(date: Date, includeSeconds = false): string {\n  return timeFormat(includeSeconds ? \"%H:%M:%S\" : \"%H:%M\")(date);\n}\n\n/**\n * Format a date as date and time\n */\nexport function formatDateTime(date: Date): string {\n  return timeFormat(\"%b %d, %Y %H:%M\")(date);\n}\n\n/**\n * Format a date as ISO string\n */\nexport function formatISODate(date: Date): string {\n  return isoFormat(date);\n}\n\n/**\n * Parse a date string into a Date object\n */\nexport function parseDate(\n  dateStr: string,\n  formatStr = \"%Y-%m-%d\"\n): Date | null {\n  return timeParse(formatStr)(dateStr);\n}\n\n/**\n * Parse an ISO date string\n */\nexport function parseISODate(dateStr: string): Date | null {\n  return isoParse(dateStr);\n}\n\n/**\n * Format duration in milliseconds to human-readable string\n */\nexport function formatDuration(ms: number): string {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n\n  if (days > 0) {\n    return `${days}d ${hours % 24}h`;\n  }\n  if (hours > 0) {\n    return `${hours}h ${minutes % 60}m`;\n  }\n  if (minutes > 0) {\n    return `${minutes}m ${seconds % 60}s`;\n  }\n  return `${seconds}s`;\n}\n\n/**\n * Format bytes to human-readable string\n */\nexport function formatBytes(bytes: number, decimals = 2): string {\n  if (bytes === 0) {\n    return \"0 Bytes\";\n  }\n\n  const k = 1024;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return `${Number.parseFloat((bytes / k ** i).toFixed(decimals))} ${sizes[i]}`;\n}\n\n/**\n * Truncate a string to a maximum length with ellipsis\n */\nexport function truncateLabel(str: string, maxLength = 20): string {\n  if (str.length <= maxLength) {\n    return str;\n  }\n  return `${str.slice(0, maxLength - 3)}...`;\n}\n\n/**\n * Create a tick formatter that abbreviates large numbers\n */\nexport function createAbbreviatedFormatter(\n  decimals = 1\n): (value: number) => string {\n  return (value: number) => {\n    const absValue = Math.abs(value);\n    if (absValue >= 1e9) {\n      return `${(value / 1e9).toFixed(decimals)}B`;\n    }\n    if (absValue >= 1e6) {\n      return `${(value / 1e6).toFixed(decimals)}M`;\n    }\n    if (absValue >= 1e3) {\n      return `${(value / 1e3).toFixed(decimals)}K`;\n    }\n    return value.toString();\n  };\n}\n\n/**\n * Create a formatter that shows ordinal suffixes (1st, 2nd, 3rd, etc.)\n */\nexport function formatOrdinal(value: number): string {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = value % 100;\n  return value + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\n\n/**\n * Format a number range\n */\nexport function formatRange(\n  min: number,\n  max: number,\n  formatter = formatNumber\n): string {\n  return `${formatter(min)} â€“ ${formatter(max)}`;\n}\n"
    },
    {
      "path": "lib/charts/index.ts",
      "type": "registry:lib",
      "content": "/** biome-ignore-all lint/performance/noBarrelFile: public API entry point for chart utilities */\n\n// Axis utilities\nexport {\n  createAxisGenerator,\n  createGridLines,\n  getTickFormat,\n  renderAxis,\n  styleAxis,\n  styleGridLines,\n} from \"./axis\";\n// Formatting utilities\nexport {\n  createAbbreviatedFormatter,\n  formatBytes,\n  formatCurrency,\n  formatDate,\n  formatDateTime,\n  formatDuration,\n  formatFullDate,\n  formatISODate,\n  formatNumber,\n  formatOrdinal,\n  formatPercent,\n  formatRange,\n  formatShortDate,\n  formatSI,\n  formatTime,\n  parseDate,\n  parseISODate,\n  truncateLabel,\n} from \"./format\";\n// Resize/responsive utilities\nexport {\n  getDevicePixelRatio,\n  getElementBounds,\n  isElementVisible,\n  scaleCanvas,\n  setSvgViewBox,\n  useChartDimensions,\n  useResizeObserver,\n} from \"./resize\";\n// Scale utilities\nexport {\n  calculateDimensions,\n  computeNumericExtent,\n  computeTimeExtent,\n  createBandScale,\n  createColorScale,\n  createLinearScale,\n  createPointScale,\n  createTimeScale,\n  getNiceTickValues,\n  getNiceTimeTickValues,\n} from \"./scales\";\n// Theme utilities\nexport {\n  categoricalPalette,\n  chartStyles,\n  defaultColorPalette,\n  divergingPalette,\n  extendedColorPalette,\n  getChartTheme,\n  getColorFromPalette,\n  getCssVariable,\n  isDarkMode,\n  sequentialPalette,\n  withOpacity,\n} from \"./theme\";\n// Tooltip utilities\nexport {\n  bisectIndex,\n  calculateTooltipPosition,\n  findClosestPoint,\n  findClosestPointByX,\n  getRelativeMousePosition,\n  useChartTooltip,\n} from \"./tooltip\";\nexport type {\n  AxisConfig,\n  AxisOrientation,\n  BandScale,\n  CategoryPoint,\n  ChartColorPalette,\n  ChartDimensions,\n  ChartMargin,\n  ChartTheme,\n  DataPoint,\n  LinearScale,\n  OrdinalScale,\n  PointScale,\n  TimeScale,\n  TimeSeriesPoint,\n  TooltipData,\n} from \"./types\";\n"
    }
  ]
}
