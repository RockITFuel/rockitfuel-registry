{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "solid-convex",
  "type": "registry:lib",
  "title": "Solid Convex",
  "description": "Reactive Convex integration for SolidJS with caching, optimistic updates, and SSR support",
  "dependencies": ["convex", "@solid-primitives/map"],
  "files": [
    {
      "path": "lib/solid-convex/index.tsx",
      "type": "registry:lib",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n/** biome-ignore-all lint/suspicious/noExplicitAny: <explanation> */\n\nimport { ReactiveMap } from \"@solid-primitives/map\";\nimport type {\n  FunctionArgs,\n  FunctionReference,\n  FunctionReturnType,\n} from \"convex/server\";\nimport { getFunctionName } from \"convex/server\";\nimport { convexToJson } from \"convex/values\";\nimport { createEffect, createMemo, onCleanup } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\n\nimport { getConvexClient, initConvex } from \"./convex-client\";\n\n/**\n * Extract a user-friendly error message from a Convex error.\n * Convex errors often contain technical details like stack traces and request IDs.\n * This function extracts just the human-readable message.\n *\n * @example\n * // Input: \"Uncaught Error: Gebruiker is al lid van dit team at handler (./convex/teams.ts:558:11)\"\n * // Output: \"Gebruiker is al lid van dit team\"\n */\nexport function getUserErrorMessage(error: Error, fallback?: string): string {\n  const defaultMessage = fallback ?? \"Er is een onverwachte fout opgetreden\";\n\n  if (!error.message) {\n    return defaultMessage;\n  }\n\n  // Try to extract the actual error message, removing technical prefixes and stack traces\n  // Pattern handles: \"Uncaught Error: <message> at handler (...)\" or just \"<message> at handler (...)\"\n  const match = error.message.match(\n    /(?:Uncaught\\s+)?(?:Error:\\s*)?(.+?)(?:\\s+at\\s+|$)/i\n  );\n  if (match?.[1]) {\n    const extracted = match[1].trim();\n    // Make sure we got something meaningful\n    if (extracted.length > 0) {\n      return extracted;\n    }\n  }\n\n  return defaultMessage;\n}\n\nexport type ConvexError = Error & { userMessage: string };\n\ninterface CacheEntry<T = unknown> {\n  data: T;\n  source: \"ssr-prefetch\" | \"csr-prefetch\" | \"csr-optimistic\" | \"subscription\";\n  timestamp: number;\n}\n\nexport const convexCacheMap = new ReactiveMap<string, CacheEntry>();\nconst inflightRequests = new Map<string, Promise<any>>();\n\ntype QueryArgsSource<Query extends FunctionReference<\"query\">> =\n  | (() => FunctionArgs<Query>)\n  | FunctionArgs<Query>\n  | undefined;\n\ntype OptimisticUpdate<\n  Mutation extends FunctionReference<\"mutation\">,\n  Query extends FunctionReference<\"query\">,\n> = {\n  query: Query;\n  args?: QueryArgsSource<Query>;\n  apply: (\n    currentData: FunctionReturnType<Query> | undefined,\n    mutationArgs: FunctionArgs<Mutation>\n  ) => FunctionReturnType<Query> | undefined;\n  rollbackOnError?: boolean;\n};\n\nexport function convexQueryKey(\n  queryKey: [\n    FunctionReference<\"query\">,\n    Record<string, any>,\n    NonNullable<unknown>,\n  ]\n): string {\n  return `${getFunctionName(queryKey[0])}|${JSON.stringify(convexToJson(queryKey[1]))}`;\n}\n\n/**\n * @example\n * export const route = {\n  load: async () => {\n    await prefetchConvex(api.todo.getAll);\n  },\n} satisfies RouteDefinition;\n\nexport default function Todo() {\n  const todos = createQuery(api.todo.getAll);\n  return (\n    <div>\n      <h1>Todos</h1>\n      <ul>\n        <For each={todos()}>{(todo) => <li>{todo.title}</li>}</For>\n      </ul>\n    </div>\n  );\n * @param query\n * @param args\n * @returns\n */\nexport const prefetchConvex = async <Query extends FunctionReference<\"query\">>(\n  query: Query,\n  args?: FunctionArgs<Query>\n): Promise<FunctionReturnType<Query> | undefined> => {\n  const key = convexQueryKey([query, args ? args : {}, {}]);\n\n  // Return existing in-flight request to prevent duplicates\n  const inflight = inflightRequests.get(key);\n  if (inflight) {\n    return inflight;\n  }\n\n  // Return cached data if available\n  const cached = convexCacheMap.get(key);\n  if (cached) {\n    return cached.data as FunctionReturnType<Query>;\n  }\n\n  // Fetch fresh data\n  const promise = (async () => {\n    if (isServer) {\n      try {\n        const { createConvexHttpClient } = await import(\n          \"../auth/start-handlers\"\n        );\n        const serverClient = createConvexHttpClient();\n        const data = await serverClient.query(query, args ? args : {});\n        if (data !== undefined) {\n          convexCacheMap.set(key, {\n            data,\n            source: \"ssr-prefetch\",\n            timestamp: Date.now(),\n          });\n        }\n        return data;\n      } catch (error) {\n        return;\n      }\n    } else {\n      await initConvex();\n      const httpClient = getConvexClient();\n      const data = await httpClient?.query(query, args ? args : {});\n      if (data !== undefined) {\n        convexCacheMap.set(key, {\n          data,\n          source: \"csr-prefetch\",\n          timestamp: Date.now(),\n        });\n      }\n      return data;\n    }\n  })().finally(() => inflightRequests.delete(key));\n\n  inflightRequests.set(key, promise);\n  return promise;\n};\n\nexport async function prefetchConvexBatch(\n  queries: Array<{\n    query: FunctionReference<\"query\">;\n    args?: Record<string, any>;\n  }>\n): Promise<void> {\n  await Promise.allSettled(\n    queries.map(({ query, args }) => prefetchConvex(query, args))\n  );\n}\n\nexport function clearConvexCache() {\n  convexCacheMap.clear();\n  inflightRequests.clear();\n}\n\n// Create a reactive SolidJS atom attached to a Convex query function.\nexport function createQuery<Query extends FunctionReference<\"query\">>(\n  query: Query,\n  options?: {\n    args?: () => FunctionArgs<Query>; // args accepts an accessor instead of plain object for reactivity changes\n    onSuccess?: (result: FunctionReturnType<Query>) => void;\n    onError?: (error: Error) => void;\n    debug?: boolean;\n    /**\n     * Whether the query should be enabled. Can be a boolean or a function that returns a boolean.\n     * When disabled, the subscription will not be set up and args will not be evaluated.\n     * @default true\n     */\n    enabled?: boolean | (() => boolean);\n  }\n): () => FunctionReturnType<Query> | undefined {\n  // Helper to check if query is enabled\n  const isEnabled = () =>\n    typeof options?.enabled === \"function\"\n      ? options.enabled()\n      : (options?.enabled ?? true);\n\n  // Derive value directly from cache - automatically updates on optimistic updates and subscription changes\n  const value = createMemo(() => {\n    // Don't evaluate args if disabled\n    if (!isEnabled()) {\n      return;\n    }\n    const key = convexQueryKey([\n      query,\n      options?.args ? options.args() : {},\n      {},\n    ]);\n    const cached = convexCacheMap.get(key);\n    return cached?.data as FunctionReturnType<Query> | undefined;\n  });\n\n  createEffect(() => {\n    // Don't evaluate args if disabled or debug is off\n    if (!(options?.debug && isEnabled())) {\n      return;\n    }\n    const fullArgs = options?.args ? options.args() : {};\n    const currentKey = convexQueryKey([query, fullArgs, {}]);\n    const cached = convexCacheMap.get(currentKey);\n    console.log(`Debug ${currentKey}: `, JSON.stringify(cached, null, 2));\n  });\n\n  // Set up Convex subscription\n  createEffect(() => {\n    // Check enabled first before evaluating args\n    if (!isEnabled()) {\n      return;\n    }\n\n    const fullArgs = options?.args ? options.args() : {};\n    const currentKey = convexQueryKey([query, fullArgs, {}]);\n    let unsubber: (() => void) | undefined;\n\n    // Initialize client asynchronously, then set up subscription\n    initConvex()\n      .then(() => {\n        unsubber = getConvexClient().onUpdate(\n          query,\n          fullArgs as FunctionArgs<Query>,\n          (result) => {\n            console.log(\"on convex subscription update\");\n            // Update cache with subscription data\n            convexCacheMap.set(currentKey, {\n              data: result,\n              source: \"subscription\",\n              timestamp: Date.now(),\n            });\n\n            options?.onSuccess?.(result);\n          },\n          (error) => {\n            options?.onError?.(error);\n          }\n        );\n      })\n      .catch((error) => {\n        options?.onError?.(error);\n      });\n\n    // Cleanup subscription when args change or effect re-runs\n    onCleanup(() => {\n      if (unsubber) {\n        unsubber();\n      }\n    });\n  });\n\n  return value;\n}\n\n/**\n * Create a Convex mutation accessor with optional optimistic updates.\n *\n * ### When to use `produce`\n * - Stores or deeply nested objects: wrap `apply` logic in Solid's `produce` for ergonomic drafts.\n * - Signals containing nested objects: consider `produce` only if manual cloning is noisy.\n * - Primitive values: return the new primitive directly to avoid extra work.\n *\n * @example\n * const createTodo = createMutation(api.todos.createTodo, {\n *   optimistic: {\n *     query: api.todos.getAllTodos,\n *     apply: (todos = [], args) => [\n *       { _id: `temp-${Date.now()}`, title: args.title, completed: false },\n *       ...todos,\n *     ]\n *   }\n * })\n */\nexport function createMutation<\n  Mutation extends FunctionReference<\"mutation\">,\n  Query extends FunctionReference<\"query\"> = FunctionReference<\"query\">,\n>(\n  mutation: Mutation,\n  options?: {\n    onSuccess?: (result: FunctionReturnType<Mutation>) => void;\n    onError?: (error: ConvexError) => void;\n    /**\n     * Configure optimistic updates by describing which cached queries should be patched\n     * before the server responds. Use Solid's `produce` helper yourself when mutating\n     * nested structures, and prefer direct immutable replacements for primitives.\n     */\n    optimistic?:\n      | OptimisticUpdate<Mutation, Query>\n      | OptimisticUpdate<Mutation, Query>[];\n    /**\n     * Debounce delay in milliseconds. When set, the mutation will only execute\n     * after the specified delay has passed without any new calls.\n     * @default 0 (no debounce)\n     */\n    debounce?: number;\n  }\n): (args?: FunctionArgs<Mutation>) => Promise<FunctionReturnType<Mutation>> {\n  const debounceMs = options?.debounce ?? 0;\n  let debounceTimeout: ReturnType<typeof setTimeout> | null = null;\n  let pendingResolve: ((value: FunctionReturnType<Mutation>) => void) | null =\n    null;\n  let pendingReject: ((error: Error) => void) | null = null;\n  const normalizeArgs = <Q extends FunctionReference<\"query\">>(\n    argsSource: QueryArgsSource<Q>\n  ): FunctionArgs<Q> => {\n    if (typeof argsSource === \"function\") {\n      return (argsSource as () => FunctionArgs<Q>)();\n    }\n    return (argsSource ?? ({} as FunctionArgs<Q>)) as FunctionArgs<Q>;\n  };\n\n  const normalizeOptimistic = (\n    optimistic?:\n      | OptimisticUpdate<Mutation, Query>\n      | OptimisticUpdate<Mutation, Query>[]\n  ): OptimisticUpdate<Mutation, Query>[] => {\n    if (!optimistic) {\n      return [];\n    }\n    return Array.isArray(optimistic) ? optimistic : [optimistic];\n  };\n\n  const optimisticEntries = normalizeOptimistic(options?.optimistic);\n\n  // Track optimistic updates for potential rollback on error\n  let appliedOptimisticEntries: Array<{\n    key: string;\n    previous?: CacheEntry;\n    shouldRollback: boolean;\n  }> = [];\n\n  const applyOptimisticUpdate = (\n    optimistic: OptimisticUpdate<Mutation, Query>,\n    fullArgs: FunctionArgs<Mutation>\n  ) => {\n    const resolvedArgs = normalizeArgs(optimistic.args);\n    const cacheKey = convexQueryKey([\n      optimistic.query,\n      resolvedArgs as Record<string, any>,\n      {},\n    ]);\n\n    const existingEntry = convexCacheMap.get(cacheKey) as\n      | CacheEntry<FunctionReturnType<Query>>\n      | undefined;\n\n    const nextData = optimistic.apply(existingEntry?.data, fullArgs);\n    if (nextData === undefined) {\n      return;\n    }\n\n    // Only store the first previous entry for this key (for proper rollback)\n    if (!appliedOptimisticEntries.some((entry) => entry.key === cacheKey)) {\n      appliedOptimisticEntries.push({\n        key: cacheKey,\n        previous: existingEntry,\n        shouldRollback: optimistic.rollbackOnError !== false,\n      });\n    }\n\n    convexCacheMap.set(cacheKey, {\n      data: nextData,\n      source: \"csr-optimistic\",\n      timestamp: Date.now(),\n    });\n  };\n\n  const rollbackOptimisticUpdates = () => {\n    appliedOptimisticEntries.forEach(({ key, previous, shouldRollback }) => {\n      if (!shouldRollback) {\n        return;\n      }\n      if (previous) {\n        convexCacheMap.set(key, previous);\n        return;\n      }\n      convexCacheMap.delete(key);\n    });\n    appliedOptimisticEntries = [];\n  };\n\n  const executeNetworkCall = async (\n    fullArgs: FunctionArgs<Mutation>\n  ): Promise<FunctionReturnType<Mutation>> => {\n    await initConvex();\n\n    return getConvexClient()\n      .mutation(mutation, fullArgs)\n      .then((result) => {\n        // Clear tracked optimistic entries on success (subscription will update cache)\n        appliedOptimisticEntries = [];\n        options?.onSuccess?.(result);\n        return result;\n      })\n      .catch((error: Error) => {\n        rollbackOptimisticUpdates();\n        const convexError: ConvexError = Object.assign(error, {\n          userMessage: getUserErrorMessage(error),\n        });\n        options?.onError?.(convexError);\n        throw error;\n      });\n  };\n\n  return (args) => {\n    const fullArgs = args ?? ({} as FunctionArgs<Mutation>);\n\n    // Apply optimistic updates immediately\n    for (const optimistic of optimisticEntries) {\n      applyOptimisticUpdate(optimistic, fullArgs);\n    }\n\n    // No debounce - execute network call immediately\n    if (debounceMs <= 0) {\n      return executeNetworkCall(fullArgs);\n    }\n\n    // Clear any pending debounced call\n    if (debounceTimeout) {\n      clearTimeout(debounceTimeout);\n    }\n\n    // Return a promise that will resolve when the debounced network call executes\n    return new Promise<FunctionReturnType<Mutation>>((resolve, reject) => {\n      pendingResolve = resolve;\n      pendingReject = reject;\n\n      debounceTimeout = setTimeout(() => {\n        debounceTimeout = null;\n        executeNetworkCall(fullArgs)\n          .then((result) => {\n            pendingResolve?.(result);\n            pendingResolve = null;\n            pendingReject = null;\n          })\n          .catch((error) => {\n            pendingReject?.(error);\n            pendingResolve = null;\n            pendingReject = null;\n          });\n      }, debounceMs);\n    });\n  };\n}\n\nexport function createAction<Action extends FunctionReference<\"action\">>(\n  action: Action,\n  options?: {\n    onSuccess?: (result: FunctionReturnType<Action>) => void;\n    onError?: (error: ConvexError) => void;\n  }\n): (args?: FunctionArgs<Action>) => Promise<FunctionReturnType<Action>> {\n  return async (args) => {\n    await initConvex();\n    const fullArgs = args ?? ({} as FunctionArgs<Action>);\n    return getConvexClient()\n      .action(action, fullArgs)\n      .then((result) => {\n        options?.onSuccess?.(result);\n        return Promise.resolve(result);\n      })\n      .catch((error: Error) => {\n        const convexError: ConvexError = Object.assign(error, {\n          userMessage: getUserErrorMessage(error),\n        });\n        options?.onError?.(convexError);\n        return Promise.reject(error);\n      });\n  };\n}\n"
    },
    {
      "path": "lib/solid-convex/convex-client.ts",
      "type": "registry:lib",
      "content": "import { ConvexClient } from \"convex/browser\";\nimport { getPublicEnv } from \"./server\";\n\nlet convexClientInstance: ConvexClient | null = null;\nlet initPromise: Promise<ConvexClient> | null = null;\nlet authSetup = false;\n\n/**\n * Initialize the Convex client with runtime configuration.\n * This fetches the CONVEX_URL from the server at runtime, allowing for\n * proper containerization where env vars are set when the container starts.\n */\nexport const initConvex = async (): Promise<ConvexClient> => {\n  if (convexClientInstance) {\n    return convexClientInstance;\n  }\n\n  // If initialization is already in progress, wait for it\n  if (initPromise) {\n    return initPromise;\n  }\n\n  initPromise = (async () => {\n    const { CONVEX_URL } = await getPublicEnv();\n\n    if (!CONVEX_URL) {\n      throw new Error(\n        \"CONVEX_URL is not configured. Please set the CONVEX_URL environment variable in your container/server.\"\n      );\n    }\n\n    convexClientInstance = new ConvexClient(CONVEX_URL);\n\n    return convexClientInstance;\n  })();\n\n  return initPromise;\n};\n\n// Export getter function to ensure client is initialized\n// This will lazily initialize the client if it hasn't been initialized yet\nexport function getConvexClient(): ConvexClient {\n  if (!convexClientInstance) {\n    throw new Error(\n      \"Convex client not initialized. Call initConvex() first or ensure CONVEX_URL is set.\"\n    );\n  }\n  return convexClientInstance;\n}\n\n// Optional: Setup function for auth\nexport function setupConvexAuth(\n  fetchToken: (opts: { forceRefreshToken: boolean }) => Promise<string | null>\n) {\n  if (!convexClientInstance) {\n    throw new Error(\"Convex client not initialized. Call initConvex() first.\");\n  }\n  authSetup = true;\n  convexClientInstance.setAuth(fetchToken);\n}\n"
    },
    {
      "path": "lib/solid-convex/server.ts",
      "type": "registry:lib",
      "content": "/**\n * Server function to get public environment variables at runtime.\n * This is called from the client to fetch env vars after the container starts,\n * allowing for runtime configuration instead of build-time.\n *\n * Note: We access process.env directly here instead of using serverEnv\n * to avoid circular dependency issues during server function extraction.\n */\nexport const getPublicEnv = (): Promise<{\n  CONVEX_URL: string;\n}> => {\n  \"use server\";\n\n  const convexUrl = process.env.CONVEX_URL;\n\n  if (!convexUrl) {\n    throw new Error(\n      \"CONVEX_URL environment variable is not set. Please configure it in your deployment environment.\"\n    );\n  }\n\n  return Promise.resolve({\n    CONVEX_URL: convexUrl,\n  });\n};\n"
    }
  ]
}
