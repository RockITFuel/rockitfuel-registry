{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "solid-convex",
  "type": "registry:lib",
  "title": "Solid Convex",
  "description": "Reactive Convex integration for SolidJS with caching, optimistic updates, and SSR support",
  "dependencies": ["convex", "@solid-primitives/map"],
  "files": [
    {
      "path": "lib/solid-convex/index.tsx",
      "type": "registry:lib",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n/** biome-ignore-all lint/suspicious/noExplicitAny: <explanation> */\n\nimport { ReactiveMap } from \"@solid-primitives/map\";\nimport type {\n\tFunctionArgs,\n\tFunctionReference,\n\tFunctionReturnType,\n} from \"convex/server\";\nimport { getFunctionName } from \"convex/server\";\nimport { convexToJson } from \"convex/values\";\nimport { createEffect, createMemo, onCleanup } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\n\nimport { getConvexClient, initConvex } from \"./convex-client\";\n\n/**\n * Extract a user-friendly error message from a Convex error.\n * Convex errors often contain technical details like stack traces and request IDs.\n * This function extracts just the human-readable message.\n *\n * @example\n * // Input: \"Uncaught Error: Gebruiker is al lid van dit team at handler (./convex/teams.ts:558:11)\"\n * // Output: \"Gebruiker is al lid van dit team\"\n */\nexport function getUserErrorMessage(error: Error, fallback?: string): string {\n\tconst defaultMessage = fallback ?? \"Er is een onverwachte fout opgetreden\";\n\n\tif (!error.message) {\n\t\treturn defaultMessage;\n\t}\n\n\t// Try to extract the actual error message, removing technical prefixes and stack traces\n\t// Pattern handles: \"Uncaught Error: <message> at handler (...)\" or just \"<message> at handler (...)\"\n\tconst match = error.message.match(\n\t\t/(?:Uncaught\\s+)?(?:Error:\\s*)?(.+?)(?:\\s+at\\s+|$)/i,\n\t);\n\tif (match?.[1]) {\n\t\tconst extracted = match[1].trim();\n\t\t// Make sure we got something meaningful\n\t\tif (extracted.length > 0) {\n\t\t\treturn extracted;\n\t\t}\n\t}\n\n\treturn defaultMessage;\n}\n\nexport type ConvexError = Error & { userMessage: string };\n\ninterface CacheEntry<T = unknown> {\n\tdata: T;\n\tsource: \"ssr-prefetch\" | \"csr-prefetch\" | \"csr-optimistic\" | \"subscription\";\n\ttimestamp: number;\n}\n\nexport const convexCacheMap = new ReactiveMap<string, CacheEntry>();\nconst inflightRequests = new Map<string, Promise<any>>();\n\ntype QueryArgsSource<Query extends FunctionReference<\"query\">> =\n\t| (() => FunctionArgs<Query>)\n\t| FunctionArgs<Query>\n\t| undefined;\n\ntype OptimisticUpdate<\n\tMutation extends FunctionReference<\"mutation\">,\n\tQuery extends FunctionReference<\"query\">,\n> = {\n\tquery: Query;\n\targs?: QueryArgsSource<Query>;\n\tapply: (\n\t\tcurrentData: FunctionReturnType<Query> | undefined,\n\t\tmutationArgs: FunctionArgs<Mutation>,\n\t) => FunctionReturnType<Query> | undefined;\n\trollbackOnError?: boolean;\n};\n\nexport function convexQueryKey(\n\tqueryKey: [\n\t\tFunctionReference<\"query\">,\n\t\tRecord<string, any>,\n\t\tNonNullable<unknown>,\n\t],\n): string {\n\treturn `${getFunctionName(queryKey[0])}|${JSON.stringify(convexToJson(queryKey[1]))}`;\n}\n\n/**\n * @example\n * export const route = {\n  load: async () => {\n    await prefetchConvex(api.todo.getAll);\n  },\n} satisfies RouteDefinition;\n\nexport default function Todo() {\n  const todos = createQuery(api.todo.getAll);\n  return (\n    <div>\n      <h1>Todos</h1>\n      <ul>\n        <For each={todos()}>{(todo) => <li>{todo.title}</li>}</For>\n      </ul>\n    </div>\n  );\n * @param query\n * @param args\n * @returns\n */\nexport const prefetchConvex = async <Query extends FunctionReference<\"query\">>(\n\tquery: Query,\n\targs?: FunctionArgs<Query>,\n): Promise<FunctionReturnType<Query> | undefined> => {\n\tconst key = convexQueryKey([query, args ? args : {}, {}]);\n\n\t// Return existing in-flight request to prevent duplicates\n\tconst inflight = inflightRequests.get(key);\n\tif (inflight) {\n\t\treturn inflight;\n\t}\n\n\t// Return cached data if available\n\tconst cached = convexCacheMap.get(key);\n\tif (cached) {\n\t\treturn cached.data as FunctionReturnType<Query>;\n\t}\n\n\t// Fetch fresh data\n\tconst promise = (async () => {\n\t\tif (isServer) {\n\t\t\ttry {\n\t\t\t\tconst { createConvexHttpClient } = await import(\n\t\t\t\t\t\"../auth/start-handlers\"\n\t\t\t\t);\n\t\t\t\tconst serverClient = createConvexHttpClient();\n\t\t\t\tconst data = await serverClient.query(query, args ? args : {});\n\t\t\t\tif (data !== undefined) {\n\t\t\t\t\tconvexCacheMap.set(key, {\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tsource: \"ssr-prefetch\",\n\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t} catch (error) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tawait initConvex();\n\t\t\tconst httpClient = getConvexClient();\n\t\t\tconst data = await httpClient?.query(query, args ? args : {});\n\t\t\tif (data !== undefined) {\n\t\t\t\tconvexCacheMap.set(key, {\n\t\t\t\t\tdata,\n\t\t\t\t\tsource: \"csr-prefetch\",\n\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\t})().finally(() => inflightRequests.delete(key));\n\n\tinflightRequests.set(key, promise);\n\treturn promise;\n};\n\nexport async function prefetchConvexBatch(\n\tqueries: Array<{\n\t\tquery: FunctionReference<\"query\">;\n\t\targs?: Record<string, any>;\n\t}>,\n): Promise<void> {\n\tawait Promise.allSettled(\n\t\tqueries.map(({ query, args }) => prefetchConvex(query, args)),\n\t);\n}\n\nexport function clearConvexCache() {\n\tconvexCacheMap.clear();\n\tinflightRequests.clear();\n}\n\n// Create a reactive SolidJS atom attached to a Convex query function.\nexport function createQuery<Query extends FunctionReference<\"query\">>(\n\tquery: Query,\n\toptions?: {\n\t\targs?: () => FunctionArgs<Query>; // args accepts an accessor instead of plain object for reactivity changes\n\t\tonSuccess?: (result: FunctionReturnType<Query>) => void;\n\t\tonError?: (error: Error) => void;\n\t\tdebug?: boolean;\n\t\t/**\n\t\t * Whether the query should be enabled. Can be a boolean or a function that returns a boolean.\n\t\t * When disabled, the subscription will not be set up and args will not be evaluated.\n\t\t * @default true\n\t\t */\n\t\tenabled?: boolean | (() => boolean);\n\t},\n): () => FunctionReturnType<Query> | undefined {\n\t// Helper to check if query is enabled\n\tconst isEnabled = () =>\n\t\ttypeof options?.enabled === \"function\"\n\t\t\t? options.enabled()\n\t\t\t: (options?.enabled ?? true);\n\n\t// Derive value directly from cache - automatically updates on optimistic updates and subscription changes\n\tconst value = createMemo(() => {\n\t\t// Don't evaluate args if disabled\n\t\tif (!isEnabled()) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst key = convexQueryKey([\n\t\t\tquery,\n\t\t\toptions?.args ? options.args() : {},\n\t\t\t{},\n\t\t]);\n\t\tconst cached = convexCacheMap.get(key);\n\t\treturn cached?.data as FunctionReturnType<Query> | undefined;\n\t});\n\n\tcreateEffect(() => {\n\t\t// Don't evaluate args if disabled or debug is off\n\t\tif (!options?.debug || !isEnabled()) {\n\t\t\treturn;\n\t\t}\n\t\tconst fullArgs = options?.args ? options.args() : {};\n\t\tconst currentKey = convexQueryKey([query, fullArgs, {}]);\n\t\tconst cached = convexCacheMap.get(currentKey);\n\t\tconsole.log(`Debug ${currentKey}: `, JSON.stringify(cached, null, 2));\n\t});\n\n\t// Set up Convex subscription\n\tcreateEffect(() => {\n\t\t// Check enabled first before evaluating args\n\t\tif (!isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst fullArgs = options?.args ? options.args() : {};\n\t\tconst currentKey = convexQueryKey([query, fullArgs, {}]);\n\t\tlet unsubber: (() => void) | undefined;\n\n\t\t// Initialize client asynchronously, then set up subscription\n\t\tinitConvex()\n\t\t\t.then(() => {\n\t\t\t\tunsubber = getConvexClient().onUpdate(\n\t\t\t\t\tquery,\n\t\t\t\t\tfullArgs as FunctionArgs<Query>,\n\t\t\t\t\t(result) => {\n\t\t\t\t\t\tconsole.log(\"on convex subscription update\");\n\t\t\t\t\t\t// Update cache with subscription data\n\t\t\t\t\t\tconvexCacheMap.set(currentKey, {\n\t\t\t\t\t\t\tdata: result,\n\t\t\t\t\t\t\tsource: \"subscription\",\n\t\t\t\t\t\t\ttimestamp: Date.now(),\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\toptions?.onSuccess?.(result);\n\t\t\t\t\t},\n\t\t\t\t\t(error) => {\n\t\t\t\t\t\toptions?.onError?.(error);\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\toptions?.onError?.(error);\n\t\t\t});\n\n\t\t// Cleanup subscription when args change or effect re-runs\n\t\tonCleanup(() => {\n\t\t\tif (unsubber) {\n\t\t\t\tunsubber();\n\t\t\t}\n\t\t});\n\t});\n\n\treturn value;\n}\n\n/**\n * Create a Convex mutation accessor with optional optimistic updates.\n *\n * ### When to use `produce`\n * - Stores or deeply nested objects: wrap `apply` logic in Solid's `produce` for ergonomic drafts.\n * - Signals containing nested objects: consider `produce` only if manual cloning is noisy.\n * - Primitive values: return the new primitive directly to avoid extra work.\n *\n * @example\n * const createTodo = createMutation(api.todos.createTodo, {\n *   optimistic: {\n *     query: api.todos.getAllTodos,\n *     apply: (todos = [], args) => [\n *       { _id: `temp-${Date.now()}`, title: args.title, completed: false },\n *       ...todos,\n *     ]\n *   }\n * })\n */\nexport function createMutation<\n\tMutation extends FunctionReference<\"mutation\">,\n\tQuery extends FunctionReference<\"query\"> = FunctionReference<\"query\">,\n>(\n\tmutation: Mutation,\n\toptions?: {\n\t\tonSuccess?: (result: FunctionReturnType<Mutation>) => void;\n\t\tonError?: (error: ConvexError) => void;\n\t\t/**\n\t\t * Configure optimistic updates by describing which cached queries should be patched\n\t\t * before the server responds. Use Solid's `produce` helper yourself when mutating\n\t\t * nested structures, and prefer direct immutable replacements for primitives.\n\t\t */\n\t\toptimistic?:\n\t\t\t| OptimisticUpdate<Mutation, Query>\n\t\t\t| OptimisticUpdate<Mutation, Query>[];\n\t\t/**\n\t\t * Debounce delay in milliseconds. When set, the mutation will only execute\n\t\t * after the specified delay has passed without any new calls.\n\t\t * @default 0 (no debounce)\n\t\t */\n\t\tdebounce?: number;\n\t},\n): (args?: FunctionArgs<Mutation>) => Promise<FunctionReturnType<Mutation>> {\n\tconst debounceMs = options?.debounce ?? 0;\n\tlet debounceTimeout: ReturnType<typeof setTimeout> | null = null;\n\tlet pendingResolve: ((value: FunctionReturnType<Mutation>) => void) | null =\n\t\tnull;\n\tlet pendingReject: ((error: Error) => void) | null = null;\n\tconst normalizeArgs = <Q extends FunctionReference<\"query\">>(\n\t\targsSource: QueryArgsSource<Q>,\n\t): FunctionArgs<Q> => {\n\t\tif (typeof argsSource === \"function\") {\n\t\t\treturn (argsSource as () => FunctionArgs<Q>)();\n\t\t}\n\t\treturn (argsSource ?? ({} as FunctionArgs<Q>)) as FunctionArgs<Q>;\n\t};\n\n\tconst normalizeOptimistic = (\n\t\toptimistic?:\n\t\t\t| OptimisticUpdate<Mutation, Query>\n\t\t\t| OptimisticUpdate<Mutation, Query>[],\n\t): OptimisticUpdate<Mutation, Query>[] => {\n\t\tif (!optimistic) {\n\t\t\treturn [];\n\t\t}\n\t\treturn Array.isArray(optimistic) ? optimistic : [optimistic];\n\t};\n\n\tconst optimisticEntries = normalizeOptimistic(options?.optimistic);\n\n\t// Track optimistic updates for potential rollback on error\n\tlet appliedOptimisticEntries: Array<{\n\t\tkey: string;\n\t\tprevious?: CacheEntry;\n\t\tshouldRollback: boolean;\n\t}> = [];\n\n\tconst applyOptimisticUpdate = (\n\t\toptimistic: OptimisticUpdate<Mutation, Query>,\n\t\tfullArgs: FunctionArgs<Mutation>,\n\t) => {\n\t\tconst resolvedArgs = normalizeArgs(optimistic.args);\n\t\tconst cacheKey = convexQueryKey([\n\t\t\toptimistic.query,\n\t\t\tresolvedArgs as Record<string, any>,\n\t\t\t{},\n\t\t]);\n\n\t\tconst existingEntry = convexCacheMap.get(cacheKey) as\n\t\t\t| CacheEntry<FunctionReturnType<Query>>\n\t\t\t| undefined;\n\n\t\tconst nextData = optimistic.apply(existingEntry?.data, fullArgs);\n\t\tif (nextData === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only store the first previous entry for this key (for proper rollback)\n\t\tif (!appliedOptimisticEntries.some((entry) => entry.key === cacheKey)) {\n\t\t\tappliedOptimisticEntries.push({\n\t\t\t\tkey: cacheKey,\n\t\t\t\tprevious: existingEntry,\n\t\t\t\tshouldRollback: optimistic.rollbackOnError !== false,\n\t\t\t});\n\t\t}\n\n\t\tconvexCacheMap.set(cacheKey, {\n\t\t\tdata: nextData,\n\t\t\tsource: \"csr-optimistic\",\n\t\t\ttimestamp: Date.now(),\n\t\t});\n\t};\n\n\tconst rollbackOptimisticUpdates = () => {\n\t\tappliedOptimisticEntries.forEach(({ key, previous, shouldRollback }) => {\n\t\t\tif (!shouldRollback) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (previous) {\n\t\t\t\tconvexCacheMap.set(key, previous);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconvexCacheMap.delete(key);\n\t\t});\n\t\tappliedOptimisticEntries = [];\n\t};\n\n\tconst executeNetworkCall = async (\n\t\tfullArgs: FunctionArgs<Mutation>,\n\t): Promise<FunctionReturnType<Mutation>> => {\n\t\tawait initConvex();\n\n\t\treturn getConvexClient()\n\t\t\t.mutation(mutation, fullArgs)\n\t\t\t.then((result) => {\n\t\t\t\t// Clear tracked optimistic entries on success (subscription will update cache)\n\t\t\t\tappliedOptimisticEntries = [];\n\t\t\t\toptions?.onSuccess?.(result);\n\t\t\t\treturn result;\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\trollbackOptimisticUpdates();\n\t\t\t\tconst convexError: ConvexError = Object.assign(error, {\n\t\t\t\t\tuserMessage: getUserErrorMessage(error),\n\t\t\t\t});\n\t\t\t\toptions?.onError?.(convexError);\n\t\t\t\tthrow error;\n\t\t\t});\n\t};\n\n\treturn (args) => {\n\t\tconst fullArgs = args ?? ({} as FunctionArgs<Mutation>);\n\n\t\t// Apply optimistic updates immediately\n\t\tfor (const optimistic of optimisticEntries) {\n\t\t\tapplyOptimisticUpdate(optimistic, fullArgs);\n\t\t}\n\n\t\t// No debounce - execute network call immediately\n\t\tif (debounceMs <= 0) {\n\t\t\treturn executeNetworkCall(fullArgs);\n\t\t}\n\n\t\t// Clear any pending debounced call\n\t\tif (debounceTimeout) {\n\t\t\tclearTimeout(debounceTimeout);\n\t\t}\n\n\t\t// Return a promise that will resolve when the debounced network call executes\n\t\treturn new Promise<FunctionReturnType<Mutation>>((resolve, reject) => {\n\t\t\tpendingResolve = resolve;\n\t\t\tpendingReject = reject;\n\n\t\t\tdebounceTimeout = setTimeout(() => {\n\t\t\t\tdebounceTimeout = null;\n\t\t\t\texecuteNetworkCall(fullArgs)\n\t\t\t\t\t.then((result) => {\n\t\t\t\t\t\tpendingResolve?.(result);\n\t\t\t\t\t\tpendingResolve = null;\n\t\t\t\t\t\tpendingReject = null;\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\tpendingReject?.(error);\n\t\t\t\t\t\tpendingResolve = null;\n\t\t\t\t\t\tpendingReject = null;\n\t\t\t\t\t});\n\t\t\t}, debounceMs);\n\t\t});\n\t};\n}\n\nexport function createAction<Action extends FunctionReference<\"action\">>(\n\taction: Action,\n\toptions?: {\n\t\tonSuccess?: (result: FunctionReturnType<Action>) => void;\n\t\tonError?: (error: ConvexError) => void;\n\t},\n): (args?: FunctionArgs<Action>) => Promise<FunctionReturnType<Action>> {\n\treturn async (args) => {\n\t\tawait initConvex();\n\t\tconst fullArgs = args ?? ({} as FunctionArgs<Action>);\n\t\treturn getConvexClient()\n\t\t\t.action(action, fullArgs)\n\t\t\t.then((result) => {\n\t\t\t\toptions?.onSuccess?.(result);\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t})\n\t\t\t.catch((error: Error) => {\n\t\t\t\tconst convexError: ConvexError = Object.assign(error, {\n\t\t\t\t\tuserMessage: getUserErrorMessage(error),\n\t\t\t\t});\n\t\t\t\toptions?.onError?.(convexError);\n\t\t\t\treturn Promise.reject(error);\n\t\t\t});\n\t};\n}\n"
    },
    {
      "path": "lib/solid-convex/convex-client.ts",
      "type": "registry:lib",
      "content": "import { ConvexClient } from \"convex/browser\";\nimport { getPublicEnv } from \"./server\";\n\nlet convexClientInstance: ConvexClient | null = null;\nlet initPromise: Promise<ConvexClient> | null = null;\nlet authSetup = false;\n\n/**\n * Initialize the Convex client with runtime configuration.\n * This fetches the CONVEX_URL from the server at runtime, allowing for\n * proper containerization where env vars are set when the container starts.\n */\nexport const initConvex = async (): Promise<ConvexClient> => {\n  if (convexClientInstance) {\n    return convexClientInstance;\n  }\n\n  // If initialization is already in progress, wait for it\n  if (initPromise) {\n    return initPromise;\n  }\n\n  initPromise = (async () => {\n    const { CONVEX_URL } = await getPublicEnv();\n\n    if (!CONVEX_URL) {\n      throw new Error(\n        \"CONVEX_URL is not configured. Please set the CONVEX_URL environment variable in your container/server.\",\n      );\n    }\n\n    convexClientInstance = new ConvexClient(CONVEX_URL);\n\n    return convexClientInstance;\n  })();\n\n  return initPromise;\n};\n\n// Export getter function to ensure client is initialized\n// This will lazily initialize the client if it hasn't been initialized yet\nexport function getConvexClient(): ConvexClient {\n  if (!convexClientInstance) {\n    throw new Error(\n      \"Convex client not initialized. Call initConvex() first or ensure CONVEX_URL is set.\",\n    );\n  }\n  return convexClientInstance;\n}\n\n// Optional: Setup function for auth\nexport function setupConvexAuth(\n  fetchToken: (opts: { forceRefreshToken: boolean }) => Promise<string | null>,\n) {\n  if (!convexClientInstance) {\n    throw new Error(\"Convex client not initialized. Call initConvex() first.\");\n  }\n  authSetup = true;\n  convexClientInstance.setAuth(fetchToken);\n}\n"
    },
    {
      "path": "lib/solid-convex/server.ts",
      "type": "registry:lib",
      "content": "/**\n * Server function to get public environment variables at runtime.\n * This is called from the client to fetch env vars after the container starts,\n * allowing for runtime configuration instead of build-time.\n *\n * Note: We access process.env directly here instead of using serverEnv\n * to avoid circular dependency issues during server function extraction.\n */\nexport const getPublicEnv = (): Promise<{\n\tCONVEX_URL: string;\n}> => {\n\t\"use server\";\n\n\tconst convexUrl = process.env.CONVEX_URL;\n\n\tif (!convexUrl) {\n\t\tthrow new Error(\n\t\t\t\"CONVEX_URL environment variable is not set. Please configure it in your deployment environment.\",\n\t\t);\n\t}\n\n\treturn Promise.resolve({\n\t\tCONVEX_URL: convexUrl,\n\t});\n};\n"
    }
  ]
}
