{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "area-chart",
  "type": "registry:chart",
  "title": "Area Chart",
  "description": "D3-powered area chart component with filled areas, multiple series support, tooltips, and responsive sizing",
  "dependencies": ["d3"],
  "registryDependencies": ["chart-utils"],
  "files": [
    {
      "path": "components/charts/area-chart.tsx",
      "type": "registry:chart",
      "content": "import { area, curveMonotoneX, line, select } from \"d3\";\nimport {\n  type Component,\n  createEffect,\n  createMemo,\n  For,\n  on,\n  onMount,\n  Show,\n} from \"solid-js\";\nimport {\n  bisectIndex,\n  type ChartMargin,\n  calculateDimensions,\n  chartStyles,\n  computeNumericExtent,\n  computeTimeExtent,\n  createAxisGenerator,\n  createColorScale,\n  createLinearScale,\n  createTimeScale,\n  defaultColorPalette,\n  getColorFromPalette,\n  getRelativeMousePosition,\n  renderAxis,\n  styleAxis,\n  styleGridLines,\n  useChartTooltip,\n  useResizeObserver,\n  withOpacity,\n} from \"~/lib/charts\";\n\nexport type AreaDataPoint = {\n  x: Date | number;\n  y: number;\n  label?: string;\n};\n\nexport type AreaSeries = {\n  id: string;\n  name: string;\n  data: AreaDataPoint[];\n  color?: string;\n};\n\nexport type AreaChartProps = {\n  data: AreaSeries[];\n  width?: number;\n  height?: number;\n  margin?: Partial<ChartMargin>;\n  xAxisLabel?: string;\n  yAxisLabel?: string;\n  showGrid?: boolean;\n  showLegend?: boolean;\n  animate?: boolean;\n  curveType?: \"linear\" | \"monotone\";\n  strokeWidth?: number;\n  showLine?: boolean;\n  fillOpacity?: number;\n  stacked?: boolean;\n  colors?: readonly string[];\n  class?: string;\n};\n\ntype TooltipContent = {\n  x: Date | number;\n  y: number;\n  seriesName: string;\n  seriesId: string;\n  color: string;\n  label?: string;\n};\n\ntype FindClosestOptions = {\n  data: AreaSeries[];\n  adjustedX: number;\n  adjustedY: number;\n  xScale: (v: number | Date) => number;\n  yScale: (v: number) => number;\n  getSeriesColor: (series: AreaSeries, index: number) => string;\n};\n\nconst findClosestDataPoint = (\n  options: FindClosestOptions\n): TooltipContent | null => {\n  const { data, adjustedX, adjustedY, xScale, yScale, getSeriesColor } =\n    options;\n  let closest: TooltipContent | null = null;\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  for (let seriesIndex = 0; seriesIndex < data.length; seriesIndex++) {\n    const series = data[seriesIndex];\n    if (series.data.length === 0) {\n      continue;\n    }\n\n    const xAccessor = (d: AreaDataPoint) => xScale(d.x as number & Date);\n    const index = bisectIndex(series.data, adjustedX, xAccessor);\n    const point = series.data[index];\n    if (!point) {\n      continue;\n    }\n\n    const px = xScale(point.x as number & Date);\n    const py = yScale(point.y);\n    const distance = Math.sqrt((px - adjustedX) ** 2 + (py - adjustedY) ** 2);\n\n    if (distance < minDistance && distance < 50) {\n      minDistance = distance;\n      closest = {\n        x: point.x,\n        y: point.y,\n        seriesName: series.name,\n        seriesId: series.id,\n        color: getSeriesColor(series, seriesIndex),\n        label: point.label,\n      };\n    }\n  }\n\n  return closest;\n};\n\nexport const AreaChart: Component<AreaChartProps> = (props) => {\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let containerRef: HTMLDivElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let svgRef: SVGSVGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let xAxisRef: SVGGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let yAxisRef: SVGGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let gridRef: SVGGElement | undefined;\n\n  const tooltip = useChartTooltip<TooltipContent>();\n\n  const containerSize = useResizeObserver(() => containerRef, {\n    debounceMs: 100,\n  });\n\n  const dimensions = createMemo(() => {\n    const width = props.width ?? containerSize().width;\n    const height = props.height ?? containerSize().height ?? 300;\n    return calculateDimensions(width, height, props.margin);\n  });\n\n  const colorScale = createMemo(() => {\n    const seriesIds = props.data.map((s) => s.id);\n    const colors = props.colors ?? defaultColorPalette;\n    return createColorScale(seriesIds, colors);\n  });\n\n  const isTimeScale = createMemo(() => {\n    const firstSeries = props.data[0];\n    if (!firstSeries?.data[0]) {\n      return false;\n    }\n    return firstSeries.data[0].x instanceof Date;\n  });\n\n  const xScale = createMemo(() => {\n    const { innerWidth } = dimensions();\n    const allXValues = props.data.flatMap((s) => s.data.map((d) => d.x));\n\n    if (isTimeScale()) {\n      const extent = computeTimeExtent(allXValues as Date[]);\n      return createTimeScale(extent, [0, innerWidth], { nice: true });\n    }\n\n    const extent = computeNumericExtent(allXValues as number[], 0.05);\n    return createLinearScale(extent, [0, innerWidth], { nice: true });\n  });\n\n  const yScale = createMemo(() => {\n    const { innerHeight } = dimensions();\n    const allYValues = props.data.flatMap((s) => s.data.map((d) => d.y));\n    const extent = computeNumericExtent(allYValues, 0.1);\n    const minY = Math.min(0, extent[0]);\n    return createLinearScale([minY, extent[1]], [innerHeight, 0], {\n      nice: true,\n    });\n  });\n\n  const areaGenerator = createMemo(() => {\n    const xS = xScale();\n    const yS = yScale();\n    const { innerHeight } = dimensions();\n    const curve = props.curveType === \"monotone\" ? curveMonotoneX : undefined;\n\n    return area<AreaDataPoint>()\n      .x((d) => xS(d.x as number & Date))\n      .y0(innerHeight)\n      .y1((d) => yS(d.y))\n      .curve(curve ?? curveMonotoneX);\n  });\n\n  const lineGenerator = createMemo(() => {\n    const xS = xScale();\n    const yS = yScale();\n    const curve = props.curveType === \"monotone\" ? curveMonotoneX : undefined;\n\n    return line<AreaDataPoint>()\n      .x((d) => xS(d.x as number & Date))\n      .y((d) => yS(d.y))\n      .curve(curve ?? curveMonotoneX);\n  });\n\n  const getSeriesColor = (series: AreaSeries, index: number): string => {\n    if (series.color) {\n      return series.color;\n    }\n    return (\n      colorScale()(series.id) ??\n      getColorFromPalette(index, props.colors ?? defaultColorPalette)\n    );\n  };\n\n  onMount(() => {\n    if (xAxisRef && yAxisRef) {\n      updateAxes();\n    }\n  });\n\n  const updateAxes = () => {\n    const { innerWidth, innerHeight } = dimensions();\n\n    if (xAxisRef) {\n      const xAxis = createAxisGenerator(\"bottom\", xScale(), {\n        tickCount: Math.floor(innerWidth / 80),\n      });\n      renderAxis(xAxisRef, xAxis);\n      styleAxis(xAxisRef);\n    }\n\n    if (yAxisRef) {\n      const yAxis = createAxisGenerator(\"left\", yScale(), {\n        tickCount: Math.floor(innerHeight / 50),\n      });\n      renderAxis(yAxisRef, yAxis);\n      styleAxis(yAxisRef);\n    }\n\n    if (gridRef && props.showGrid !== false) {\n      const gridAxis = createAxisGenerator(\"left\", yScale(), {\n        tickCount: Math.floor(innerHeight / 50),\n        tickSize: -innerWidth,\n      });\n      select(gridRef).call(gridAxis);\n      styleGridLines(gridRef);\n    }\n  };\n\n  createEffect(\n    on([dimensions, xScale, yScale], () => {\n      updateAxes();\n    })\n  );\n\n  const handleMouseMove = (event: MouseEvent) => {\n    if (!svgRef) {\n      return;\n    }\n\n    const { margin } = dimensions();\n    const mousePos = getRelativeMousePosition(event, svgRef);\n    const adjustedX = mousePos.x - margin.left;\n    const adjustedY = mousePos.y - margin.top;\n\n    const closest = findClosestDataPoint({\n      data: props.data,\n      adjustedX,\n      adjustedY,\n      xScale: xScale(),\n      yScale: yScale(),\n      getSeriesColor,\n    });\n\n    if (closest) {\n      tooltip.show(closest, { x: mousePos.x, y: mousePos.y });\n    } else {\n      tooltip.hide();\n    }\n  };\n\n  const handleMouseLeave = () => {\n    tooltip.hide();\n  };\n\n  const formatTooltipX = (x: Date | number | undefined): string => {\n    if (x === undefined) {\n      return \"\";\n    }\n    if (x instanceof Date) {\n      return x.toLocaleDateString(undefined, {\n        month: \"short\",\n        day: \"numeric\",\n        year: \"numeric\",\n      });\n    }\n    return String(x);\n  };\n\n  const formatTooltipY = (y: number | undefined): string => {\n    if (y === undefined) {\n      return \"\";\n    }\n    return y.toLocaleString(undefined, {\n      maximumFractionDigits: 2,\n    });\n  };\n\n  const fillOpacity = () => props.fillOpacity ?? 0.3;\n\n  return (\n    <div\n      class={`relative w-full ${props.class ?? \"\"}`}\n      ref={containerRef}\n      style={{ \"min-height\": `${props.height ?? 300}px` }}\n    >\n      <Show when={dimensions().width > 0 && dimensions().height > 0}>\n        {/* biome-ignore lint/a11y/noSvgWithoutTitle: Chart with programmatic tooltip */}\n        {/* biome-ignore lint/a11y/noNoninteractiveElementInteractions: Chart interaction */}\n        <svg\n          class=\"select-none\"\n          height={dimensions().height}\n          onMouseLeave={handleMouseLeave}\n          onMouseMove={handleMouseMove}\n          ref={svgRef}\n          width={dimensions().width}\n        >\n          <g\n            transform={`translate(${dimensions().margin.left},${dimensions().margin.top})`}\n          >\n            <Show when={props.showGrid !== false}>\n              <g class=\"grid\" ref={gridRef} />\n            </Show>\n\n            <For each={props.data}>\n              {(series, index) => {\n                const color = () => getSeriesColor(series, index());\n                const areaPath = () => areaGenerator()(series.data) ?? \"\";\n                const linePath = () => lineGenerator()(series.data) ?? \"\";\n\n                return (\n                  <g class=\"series\">\n                    <path\n                      d={areaPath()}\n                      fill={withOpacity(color(), fillOpacity())}\n                      stroke=\"none\"\n                    />\n\n                    <Show when={props.showLine !== false}>\n                      <path\n                        d={linePath()}\n                        fill=\"none\"\n                        stroke={color()}\n                        stroke-linecap=\"round\"\n                        stroke-linejoin=\"round\"\n                        stroke-width={props.strokeWidth ?? 2}\n                      />\n                    </Show>\n                  </g>\n                );\n              }}\n            </For>\n\n            <g\n              class=\"x-axis\"\n              ref={xAxisRef}\n              transform={`translate(0,${dimensions().innerHeight})`}\n            />\n            <g class=\"y-axis\" ref={yAxisRef} />\n\n            <Show when={props.xAxisLabel}>\n              <text\n                fill={chartStyles.axis.text}\n                font-size={chartStyles.axis.fontSize}\n                text-anchor=\"middle\"\n                x={dimensions().innerWidth / 2}\n                y={dimensions().innerHeight + dimensions().margin.bottom - 5}\n              >\n                {props.xAxisLabel}\n              </text>\n            </Show>\n\n            <Show when={props.yAxisLabel}>\n              <text\n                fill={chartStyles.axis.text}\n                font-size={chartStyles.axis.fontSize}\n                text-anchor=\"middle\"\n                transform=\"rotate(-90)\"\n                x={-dimensions().innerHeight / 2}\n                y={-dimensions().margin.left + 15}\n              >\n                {props.yAxisLabel}\n              </text>\n            </Show>\n          </g>\n        </svg>\n\n        <Show when={props.showLegend !== false && props.data.length > 1}>\n          <div class=\"mt-4 flex flex-wrap justify-center gap-4\">\n            <For each={props.data}>\n              {(series, index) => (\n                <div class=\"flex items-center gap-2\">\n                  <span\n                    class=\"h-3 w-3 rounded-full\"\n                    style={{ background: getSeriesColor(series, index()) }}\n                  />\n                  <span class=\"text-muted-foreground text-sm\">\n                    {series.name}\n                  </span>\n                </div>\n              )}\n            </For>\n          </div>\n        </Show>\n\n        <Show when={tooltip.isVisible()}>\n          <div\n            class=\"pointer-events-none absolute z-50 rounded-md border px-3 py-2 shadow-md\"\n            style={{\n              left: `${tooltip.state().position.x + 10}px`,\n              top: `${tooltip.state().position.y + 10}px`,\n              background: chartStyles.tooltip.background,\n              border: `1px solid ${chartStyles.tooltip.border}`,\n              color: chartStyles.tooltip.text,\n              \"box-shadow\": chartStyles.tooltip.shadow,\n            }}\n          >\n            <div class=\"flex items-center gap-2\">\n              <span\n                class=\"h-2 w-2 rounded-full\"\n                style={{ background: tooltip.state().data?.color }}\n              />\n              <span class=\"font-medium\">\n                {tooltip.state().data?.seriesName}\n              </span>\n            </div>\n            <div class=\"mt-1 text-muted-foreground text-sm\">\n              <div>{formatTooltipX(tooltip.state().data?.x)}</div>\n              <div class=\"font-medium text-foreground\">\n                {formatTooltipY(tooltip.state().data?.y)}\n              </div>\n              <Show when={tooltip.state().data?.label}>\n                <div class=\"text-xs\">{tooltip.state().data?.label}</div>\n              </Show>\n            </div>\n          </div>\n        </Show>\n      </Show>\n    </div>\n  );\n};\n\nexport default AreaChart;\n"
    }
  ]
}
