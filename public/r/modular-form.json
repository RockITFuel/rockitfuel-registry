{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "modular-form",
  "type": "registry:modular",
  "title": "Modular Form",
  "description": "Form components integrated with @modular-forms/solid - includes input, select, combobox, date picker, color picker, and more",
  "dependencies": [
    "@modular-forms/solid",
    "@ark-ui/solid",
    "@internationalized/date",
    "date-fns",
    "solid-motionone",
    "debounce"
  ],
  "files": [
    {
      "path": "components/modular-form/modular-input.tsx",
      "type": "registry:component",
      "content": "import { XIcon } from \"lucide-solid\";\nimport type { Component, ComponentProps, JSX } from \"solid-js\";\nimport { createEffect, createSignal, Show, splitProps } from \"solid-js\";\nimport { Motion, Presence } from \"solid-motionone\";\nimport { cn } from \"~/lib/utils\";\nimport { ModularError } from \"./modular-error\";\nimport { ModularLabel } from \"./modular-label\";\n\nconst ModularInput: Component<\n  ComponentProps<\"input\"> & {\n    label?: string;\n    error?: string;\n    name: string;\n    wrapperClass?: string;\n    labelClass?: string;\n    errorClass?: string;\n    clearable?: boolean;\n    icon?: JSX.Element;\n  }\n> = (props) => {\n  const [local, others] = splitProps(props, [\n    \"type\",\n    \"class\",\n    \"label\",\n    \"error\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"clearable\",\n    \"icon\",\n  ]);\n\n  const [ref, setRef] = createSignal<HTMLInputElement>();\n  const [value, setValue] = createSignal(\"\");\n\n  createEffect(() => {\n    const inputRef = ref();\n    if (inputRef) {\n      setValue(inputRef?.value);\n\n      const handleInput = (e: Event) => {\n        const target = e.target as HTMLInputElement;\n        setValue(target?.value);\n      };\n\n      inputRef.addEventListener(\"input\", handleInput);\n      // Return cleanup function\n      return () => {\n        inputRef.removeEventListener(\"input\", handleInput);\n      };\n    }\n  });\n\n  const dispatchInputEvent = () => {\n    //https://github.com/fabian-hiller/modular-forms/issues/221#issuecomment-2212450429\n    const input = document.getElementById(\n      `${others.name}-modular-input`\n    ) as HTMLInputElement;\n    input.dispatchEvent(new Event(\"input\", { bubbles: true, composed: true }));\n  };\n\n  const inputId = () => `${others.name}-modular-input`;\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n      <ModularLabel\n        label={local.label}\n        name={inputId()}\n        required={others.required}\n      />\n      <div class=\"relative\">\n        <Show when={local.icon}>\n          <div class=\"absolute top-1/2 left-3 -translate-y-1/2 text-muted-foreground\">\n            {local.icon}\n          </div>\n        </Show>\n        <input\n          aria-errormessage={`${props.name}-error`}\n          aria-invalid={!!props.error}\n          class={cn(\n            \"flex h-10 w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:font-medium file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n            local.class,\n            local.error && \"!ring-red-500 ring-2\",\n            local.icon && \"pl-9\"\n          )}\n          id={inputId()}\n          ref={setRef}\n          type={local.type ?? \"text\"}\n          {...others}\n        />\n        <Presence>\n          <Show when={local.clearable && value()?.length > 0}>\n            <Motion.button\n              animate={{ opacity: 1, scale: 1 }}\n              class=\"absolute top-2 right-3 -translate-y-1/2 rounded-full p-1 hover:bg-accent hover:text-accent-foreground\"\n              exit={{ opacity: 0, scale: 0.6 }}\n              initial={{ opacity: 0, scale: 0.6 }}\n              onClick={() => {\n                if (ref()) {\n                  ref()!.value = \"\";\n                  setValue(\"\");\n                  dispatchInputEvent();\n                }\n              }}\n              onPointerDown={(e) => e.stopPropagation()}\n              transition={{ duration: 0.3 }}\n              type=\"button\"\n            >\n              <XIcon class=\"size-4\" />\n            </Motion.button>\n          </Show>\n        </Presence>\n      </div>\n      <ModularError error={props.error} name={inputId()} />\n    </div>\n  );\n};\n\nexport default ModularInput;\n"
    },
    {
      "path": "components/modular-form/modular-text-area.tsx",
      "type": "registry:component",
      "content": "import type { Component, ComponentProps } from \"solid-js\";\nimport { splitProps } from \"solid-js\";\n\nimport { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\nimport { ModularLabel } from \"./modular-label\";\n\nconst ModularTextArea: Component<\n  Omit<ComponentProps<\"textarea\">, \"value\" | \"error\"> & {\n    value?: ComponentProps<\"textarea\">[\"value\"] | null;\n    label?: string;\n    error?: string;\n    name: string;\n    wrapperClass?: string;\n    labelClass?: string;\n    errorClass?: string;\n    disableResize?: boolean;\n  }\n> = (props) => {\n  const [local, others] = splitProps(props, [\n    \"class\",\n    \"label\",\n    \"error\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"disableResize\",\n  ]);\n\n  const textAreaId = () => `${others.name}-modular-text-area`;\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n      <ModularLabel\n        label={local.label}\n        name={textAreaId()}\n        required={others.required}\n      />\n      <textarea\n        aria-errormessage={`${textAreaId()}-error`}\n        aria-invalid={!!props?.error}\n        class={cn(\n          \"flex min-h-10 w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:font-medium file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          local.class,\n          local?.error && \"!ring-red-500 ring-2\",\n          local.disableResize && \"resize-none\"\n        )}\n        id={textAreaId()}\n        {...others}\n        value={props.value ?? \"\"}\n      />\n      <Expandable expanded={!!props?.error}>\n        <div class={cn(\"mt-1 text-red-500 text-sm\", local.errorClass)}>\n          {props.error}\n        </div>\n      </Expandable>\n    </div>\n  );\n};\n\nexport { ModularTextArea };\n"
    },
    {
      "path": "components/modular-form/modular-select.tsx",
      "type": "registry:component",
      "content": "import { createAsync } from \"@solidjs/router\";\nimport {\n  type ComponentProps,\n  createEffect,\n  createMemo,\n  createSignal,\n  type JSX,\n  on,\n  splitProps,\n} from \"solid-js\";\nimport { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"../ui/select\";\nimport { ModularLabel } from \"./modular-label\";\n\ntype ModularSelectPropsBase<T> = Omit<ComponentProps<\"input\">, \"value\"> & {\n  value?: ComponentProps<\"input\">[\"value\"] | null;\n  label?: string;\n  onValueChange?: (v: T | null) => void;\n  autoSelectFirstOption?: boolean;\n  optionValue?: string;\n  optionTextValue?: string;\n  optionDisabled?: string;\n  error?: string;\n  placeholder?: string;\n  name: string;\n  wrapperClass?: string;\n  labelClass?: string;\n  errorClass?: string;\n};\n\ntype ModularSelectPropsWithOptions<T> = ModularSelectPropsBase<T> & {\n  options: any[];\n  queryFn?: never; // Ensure queryFn is not provided when options are provided\n};\n\ntype ModularSelectPropsWithQueryFn<T> = ModularSelectPropsBase<T> & {\n  queryFn: (params: { where?: any }) => Promise<any[]>;\n  queryFnParams?: { where?: any };\n  options?: never; // Ensure options is not provided when queryFn is provided\n};\n\ntype ModularSelectProps<T> =\n  | ModularSelectPropsWithOptions<T>\n  | ModularSelectPropsWithQueryFn<T>;\n\nconst ModularSelect = <T,>(props: ModularSelectProps<T>): JSX.Element => {\n  const [local, others] = splitProps(props, [\n    \"class\",\n    \"label\",\n    \"error\",\n    \"queryFn\",\n    \"options\",\n    \"optionValue\",\n    \"optionTextValue\",\n    \"optionDisabled\",\n    \"autoSelectFirstOption\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n  ]);\n\n  const [value, setValue] = createSignal<any>();\n  const getValue = createMemo(() => {\n    if (value() === undefined) return;\n    return value()![local.optionValue ?? \"value\"];\n  });\n  const [initialValue, setInitialValue] = createSignal<string | undefined>(\n    (props.value as string) ?? undefined\n  );\n\n  const cacheOptions = createAsync(\n    local.queryFn !== undefined ? () => local.queryFn!({}) : async () => [],\n    {\n      initialValue: [],\n      deferStream: false,\n    }\n  );\n\n  const [options, SetOptions] = createSignal<any[]>(\n    local.queryFn ? cacheOptions() : (local.options ?? [])\n  );\n\n  createEffect(() => {\n    setInitialValue((props.value as string) ?? undefined);\n  });\n\n  createEffect(\n    on(cacheOptions, () => {\n      if (cacheOptions() === undefined || cacheOptions()!.length === 0) return;\n      SetOptions(cacheOptions()!);\n    })\n  );\n\n  createEffect(\n    on(options, () => {\n      if (options() === undefined || options().length === 0) return;\n      if (!getValue() && initialValue() !== undefined) {\n        const found = options()!.find(\n          (option) => option[local.optionValue ?? \"value\"] === initialValue()\n        );\n        if (found !== undefined) {\n          setValue(found);\n          //https://github.com/fabian-hiller/modular-forms/issues/221#issuecomment-2212450429\n          const input = document.getElementById(\n            `${others.name}-modular-select`\n          ) as HTMLInputElement;\n          input.dispatchEvent(\n            new Event(\"input\", { bubbles: true, composed: true })\n          );\n        }\n        setInitialValue(undefined);\n      }\n    })\n  );\n\n  return (\n    <>\n      <input\n        {...others}\n        class=\"!h-0\"\n        id={`${others.name}-modular-select`}\n        type=\"hidden\"\n        value={getValue()}\n      />\n      <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n        <ModularLabel\n          label={local.label}\n          name={others.name}\n          required={others.required}\n        />\n        <Select\n          disabled={others.disabled}\n          itemComponent={(props: any) => (\n            <SelectItem item={props.item}>{props.item.textValue}</SelectItem>\n          )}\n          name={others.name}\n          onChange={(e: any) => {\n            if (e === null || e === \"\") return;\n            setValue(e);\n            if (props.onValueChange) {\n              props.onValueChange(e.target.value);\n            }\n            //https://github.com/fabian-hiller/modular-forms/issues/221#issuecomment-2212450429\n            const input = document.getElementById(\n              `${others.name}-modular-select`\n            ) as HTMLInputElement;\n            if (input)\n              input.dispatchEvent(\n                new Event(\"input\", { bubbles: true, composed: true })\n              );\n\n            if (input)\n              input.dispatchEvent(\n                new Event(\"change\", { bubbles: true, composed: true })\n              );\n          }}\n          options={options()}\n          optionTextValue={local.optionTextValue ?? \"label\"}\n          optionValue={local.optionValue ?? \"value\"}\n          placeholder={others.placeholder}\n          value={value()}\n        >\n          <SelectTrigger\n            aria-label={`${others.name}-select`}\n            class={cn(\n              \"w-full\",\n              local.class,\n              local.error && \"!ring-red-500 ring-2\"\n            )}\n          >\n            <SelectValue<any>>\n              {(state: any) => {\n                if (state.selectedOption() === undefined) return \"\";\n                return state.selectedOption()[local.optionTextValue ?? \"label\"];\n              }}\n            </SelectValue>\n          </SelectTrigger>\n          <SelectContent />\n        </Select>\n        <Expandable expanded={!!props.error}>\n          <div class={cn(\"mt-1 text-red-500 text-sm\", local.errorClass)}>\n            {props.error}\n          </div>\n        </Expandable>\n      </div>\n    </>\n  );\n};\n\nexport default ModularSelect;\n"
    },
    {
      "path": "components/modular-form/modular-searchable-select.tsx",
      "type": "registry:component",
      "content": "import { createAsync } from \"@solidjs/router\";\nimport {\n  type ComponentProps,\n  createEffect,\n  createMemo,\n  createSignal,\n  type JSX,\n  on,\n  splitProps,\n} from \"solid-js\";\nimport { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\nimport { SearchableSelect } from \"../ui/searchable-select\";\nimport { ModularLabel } from \"./modular-label\";\n\ntype ModularSearchableSelectPropsBase<T> = Omit<\n  ComponentProps<\"input\">,\n  \"value\" | \"onChange\"\n> & {\n  /** Current value - string ID for single, comma-separated IDs or array for multiple */\n  value?: string | string[] | null;\n  /** Label text */\n  label?: string;\n  /** Callback when value changes (receives the raw value, not the option object) */\n  onValueChange?: (v: string | string[] | null) => void;\n  /** Key to use as the unique identifier for each option */\n  optionValue?: string;\n  /** Key to use as the display label for each option */\n  optionLabel?: string;\n  /** Key to use for chip color (hex, rgb, hsl) */\n  optionColor?: string;\n  /** Key to check if option is disabled */\n  optionDisabled?: string;\n  /** Error message */\n  error?: string;\n  /** Placeholder text when no selection */\n  placeholder?: string;\n  /** Placeholder text for search input */\n  searchPlaceholder?: string;\n  /** Form field name (required) */\n  name: string;\n  /** Enable multiple selection mode */\n  multiple?: boolean;\n  /** Enable search functionality (default: true) */\n  searchable?: boolean;\n  /** Custom empty state when no results found */\n  emptyState?: JSX.Element;\n  /** Wrapper class */\n  wrapperClass?: string;\n  /** Label class */\n  labelClass?: string;\n  /** Error class */\n  errorClass?: string;\n  /** Trigger button class */\n  triggerClass?: string;\n  /** Content popover class */\n  contentClass?: string;\n};\n\ntype ModularSearchableSelectPropsWithOptions<T> =\n  ModularSearchableSelectPropsBase<T> & {\n    options: T[];\n    queryFn?: never;\n    queryFnParams?: never;\n  };\n\ntype ModularSearchableSelectPropsWithQueryFn<T> =\n  ModularSearchableSelectPropsBase<T> & {\n    queryFn: (params: { where?: Record<string, unknown> }) => Promise<T[]>;\n    queryFnParams?: { where?: Record<string, unknown> };\n    options?: never;\n  };\n\nexport type ModularSearchableSelectProps<T> =\n  | ModularSearchableSelectPropsWithOptions<T>\n  | ModularSearchableSelectPropsWithQueryFn<T>;\n\nexport function ModularSearchableSelect<T extends Record<string, unknown>>(\n  props: ModularSearchableSelectProps<T>\n): JSX.Element {\n  const [local, others] = splitProps(props, [\n    \"class\",\n    \"label\",\n    \"error\",\n    \"queryFn\",\n    \"queryFnParams\",\n    \"options\",\n    \"optionValue\",\n    \"optionLabel\",\n    \"optionColor\",\n    \"optionDisabled\",\n    \"multiple\",\n    \"searchable\",\n    \"emptyState\",\n    \"placeholder\",\n    \"searchPlaceholder\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"triggerClass\",\n    \"contentClass\",\n    \"onValueChange\",\n  ]);\n\n  const optionValueKey = () => (local.optionValue ?? \"value\") as keyof T;\n  const optionLabelKey = () => (local.optionLabel ?? \"label\") as keyof T;\n\n  // Internal selected value state (stores option objects)\n  const [selectedValue, setSelectedValue] = createSignal<T | T[] | undefined>(\n    undefined\n  );\n\n  // Track initial value for syncing\n  const [initialValue, setInitialValue] = createSignal<\n    string | string[] | null | undefined\n  >(props.value ?? undefined);\n\n  // Async options fetching\n  const asyncOptions = createAsync(\n    local.queryFn !== undefined\n      ? () => local.queryFn!(local.queryFnParams ?? {})\n      : async () => [] as T[],\n    {\n      initialValue: [] as T[],\n      deferStream: false,\n    }\n  );\n\n  // Resolved options (from props or async)\n  const [options, setOptions] = createSignal<T[]>(\n    local.queryFn ? asyncOptions() : (local.options ?? [])\n  );\n\n  // Update initial value when prop changes\n  createEffect(() => {\n    setInitialValue(props.value ?? undefined);\n  });\n\n  // Update options when async options load\n  createEffect(\n    on(asyncOptions, () => {\n      if (asyncOptions() && asyncOptions().length > 0) {\n        setOptions(asyncOptions());\n      }\n    })\n  );\n\n  // Sync initial value to selected value when options are available\n  createEffect(\n    on(options, () => {\n      const opts = options();\n      if (!opts || opts.length === 0) return;\n\n      const initial = initialValue();\n      if (initial === undefined || initial === null) return;\n\n      if (local.multiple) {\n        // Multiple mode: find all matching options\n        const values = Array.isArray(initial)\n          ? initial\n          : typeof initial === \"string\"\n            ? initial.split(\",\").filter(Boolean)\n            : [];\n\n        const found = opts.filter((opt) =>\n          values.includes(String(opt[optionValueKey()]))\n        );\n\n        if (found.length > 0) {\n          setSelectedValue(found);\n          dispatchInputEvent();\n        }\n      } else {\n        // Single mode: find matching option\n        const found = opts.find(\n          (opt) => String(opt[optionValueKey()]) === initial\n        );\n        if (found) {\n          setSelectedValue(() => found);\n          dispatchInputEvent();\n        }\n      }\n\n      setInitialValue(undefined);\n    })\n  );\n\n  // Get the value for the hidden input\n  const getHiddenInputValue = createMemo(() => {\n    const selected = selectedValue();\n    if (selected === undefined) return \"\";\n\n    if (local.multiple) {\n      const values = selected as T[];\n      return values.map((v) => String(v[optionValueKey()])).join(\",\");\n    }\n\n    return String((selected as T)[optionValueKey()]);\n  });\n\n  // Dispatch events to notify modular-forms\n  const dispatchInputEvent = () => {\n    const input = document.getElementById(\n      `${others.name}-modular-searchable-select`\n    ) as HTMLInputElement;\n    if (input) {\n      input.dispatchEvent(\n        new Event(\"input\", { bubbles: true, composed: true })\n      );\n      input.dispatchEvent(\n        new Event(\"change\", { bubbles: true, composed: true })\n      );\n    }\n  };\n\n  // Handle selection change\n  const handleChange = (value: T | T[] | undefined) => {\n    setSelectedValue(() => value);\n    dispatchInputEvent();\n\n    // Call onValueChange with the raw value(s)\n    if (local.onValueChange) {\n      if (value === undefined) {\n        local.onValueChange(null);\n      } else if (local.multiple) {\n        const values = value as T[];\n        local.onValueChange(values.map((v) => String(v[optionValueKey()])));\n      } else {\n        local.onValueChange(String((value as T)[optionValueKey()]));\n      }\n    }\n  };\n\n  return (\n    <>\n      <input\n        {...others}\n        class=\"!h-0\"\n        id={`${others.name}-modular-searchable-select`}\n        type=\"hidden\"\n        value={getHiddenInputValue()}\n      />\n      <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n        <ModularLabel\n          class={local.labelClass}\n          label={local.label}\n          name={others.name}\n          required={others.required}\n        />\n        <SearchableSelect<T>\n          class={cn(local.class, local.error && \"!ring-red-500 ring-2\")}\n          contentClass={local.contentClass}\n          disabled={others.disabled}\n          emptyState={local.emptyState}\n          multiple={local.multiple}\n          onChange={handleChange}\n          optionColor={local.optionColor as keyof T}\n          optionDisabled={local.optionDisabled as keyof T}\n          optionLabel={optionLabelKey()}\n          options={options()}\n          optionValue={optionValueKey()}\n          placeholder={local.placeholder}\n          searchable={local.searchable}\n          searchPlaceholder={local.searchPlaceholder}\n          testId={others.name}\n          triggerClass={local.triggerClass}\n          value={selectedValue()}\n        />\n        <Expandable expanded={!!local.error}>\n          <div\n            class={cn(\"mt-1 text-red-500 text-sm\", local.errorClass)}\n            id={`${others.name}-error`}\n          >\n            {local.error}\n          </div>\n        </Expandable>\n      </div>\n    </>\n  );\n}\n\nexport default ModularSearchableSelect;\n"
    },
    {
      "path": "components/modular-form/modular-combobox.tsx",
      "type": "registry:component",
      "content": "import type { ComboboxTriggerMode } from \"@kobalte/core/combobox\";\nimport { XIcon } from \"lucide-solid\";\nimport {\n  type ComponentProps,\n  createEffect,\n  createMemo,\n  type JSX,\n  on,\n  Show,\n  splitProps,\n} from \"solid-js\";\nimport { Motion, Presence } from \"solid-motionone\";\nimport { useBindSignal } from \"~/hooks/use-bind-signal\";\nimport { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\nimport {\n  Combobox,\n  ComboboxContent,\n  ComboboxControl,\n  ComboboxInput,\n  ComboboxItem,\n  ComboboxItemIndicator,\n  ComboboxItemLabel,\n  ComboboxTrigger,\n} from \"../ui/combobox\";\nimport { ModularLabel } from \"./modular-label\";\n\ntype ModularComboboxPropsBase = Omit<ComponentProps<\"input\">, \"value\"> & {\n  value?: ComponentProps<\"input\">[\"value\"] | null;\n  label?: string;\n  clearable?: boolean;\n  autoSelectFirstOption?: boolean;\n  optionValue?: string;\n  optionTextValue?: string;\n  optionDisabled?: string;\n  error?: string;\n  placeholder?: string;\n  name: string;\n  wrapperClass?: string;\n  labelClass?: string;\n  errorClass?: string;\n  triggerMode?: ComboboxTriggerMode;\n};\n\ntype ModularComboboxPropsWithOptions<T> = ModularComboboxPropsBase & {\n  options: T[];\n  lastActionOptions?: (T & { action: (v: T) => void; icon?: JSX.Element })[];\n  firstActionOptions?: (T & { action: (v: T) => void; icon?: JSX.Element })[];\n  onValueChange: (v: T | null) => void; // Required because playwright doesnt support synthetic input events\n  idSuffix?: string;\n};\n\ntype ModularComboboxProps<T> = ModularComboboxPropsWithOptions<T>;\n\nconst ModularCombobox = <T,>(props: ModularComboboxProps<T>) => {\n  const [local, others] = splitProps(props, [\n    \"class\",\n    \"label\",\n    \"clearable\",\n    \"error\",\n    \"options\",\n    \"optionValue\",\n    \"optionTextValue\",\n    \"optionDisabled\",\n    \"autoSelectFirstOption\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"triggerMode\",\n  ]);\n\n  const options = createMemo(() => [\n    ...(props.firstActionOptions ?? []),\n    ...(local.options ?? []),\n    ...(props.lastActionOptions ?? []),\n  ]);\n\n  // This make sure that state is updated when the value in changed\n  const [getValue, setValue] = useBindSignal({\n    value: () => {\n      const opts = options();\n      if (!(opts && Array.isArray(opts))) return;\n      const optionKey = local.optionValue ?? \"value\";\n      return opts.find((option) => {\n        if (!option || typeof option !== \"object\") return false;\n        // @ts-expect-error\n        return option[optionKey] === props.value;\n      });\n    },\n  });\n\n  createEffect(\n    on([options, () => props.value], () => {\n      if (options() === undefined) return;\n      if (getValue() === undefined && props.value !== undefined) {\n        const found = options()!.find(\n          // @ts-expect-error ts(7053)\n          (option) => option[local.optionValue ?? \"value\"] === props.value\n        );\n        if (found !== undefined) {\n          // @ts-expect-error ts(7053)\n          setValue(found);\n        }\n      }\n      if (\n        local.autoSelectFirstOption &&\n        options().length > 0 &&\n        getValue() === undefined &&\n        props.value === undefined\n      ) {\n        // @ts-expect-error ts(7053)\n        setValue(options()[0]);\n      }\n    })\n  );\n\n  const dispatchInputEvent = () => {\n    //https://github.com/fabian-hiller/modular-forms/issues/221#issuecomment-2212450429\n\n    //This doesnt work with playwright though\n    //Need to have a onValueChange prop that is called when the value is changed\n    const input = document.getElementById(\n      `${others.name}-modular-combobox`\n    ) as HTMLInputElement;\n    input.dispatchEvent(new Event(\"input\", { bubbles: true, composed: true }));\n  };\n\n  const idSuffic = () =>\n    props.idSuffix ? `${others.idSuffix}-${props.name}` : others.name;\n\n  return (\n    <>\n      <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n        <ModularLabel\n          label={local.label}\n          name={others.name}\n          required={others.required}\n        />\n        <Combobox\n          disabled={others.disabled}\n          itemComponent={(props) => (\n            <ComboboxItem\n              data-test-id={`${idSuffic()}-modular-combobox-item-${props.item.textValue}`}\n              item={props.item}\n            >\n              <ComboboxItemLabel class=\"flex items-center gap-2\">\n                {(props.item.rawValue as any)?.icon &&\n                  (props.item.rawValue as any).icon}\n                {props.item.textValue}\n              </ComboboxItemLabel>\n              <ComboboxItemIndicator />\n            </ComboboxItem>\n          )}\n          onChange={(e) => {\n            if (e && typeof e === \"object\" && \"action\" in e) {\n              // Performs the action of the lastActionOptions\n              // @ts-expect-error\n              e.action(e);\n            } else {\n              // Sets the value of the combobox\n              // @ts-expect-error\n              setValue(e);\n              props.onValueChange(e as T);\n\n              console.log(\"sended values: \", e);\n            }\n          }}\n          // @ts-expect-error\n          optionLabel={local.optionTextValue ?? \"label\"}\n          // @ts-expect-error\n          options={options()}\n          // @ts-expect-error\n          optionTextValue={local.optionTextValue ?? \"label\"}\n          optionValue={local.optionValue ?? \"value\"}\n          // value={getValue()}\n          triggerMode={local.triggerMode}\n          value={getValue()}\n        >\n          <ComboboxControl\n            aria-label={local.label}\n            class={cn(local.error && \"!ring-red-500 ring-2\")}\n          >\n            {(state) => (\n              <>\n                <ComboboxInput\n                  id={`${idSuffic()}-modular-combobox-input`}\n                  onInput={(e) => {\n                    //@ts-expect-error\n                    // setUISearchValue(e.target.value);\n                  }}\n                />\n                <Presence>\n                  <Show when={local.clearable && getValue()}>\n                    <Motion.button\n                      animate={{ opacity: 1, scale: 1 }}\n                      class=\"rounded-full p-1 hover:bg-accent hover:text-accent-foreground\"\n                      exit={{ opacity: 0, scale: 0.6 }}\n                      initial={{ opacity: 0, scale: 0.6 }}\n                      onClick={() => {\n                        setValue(undefined);\n                        state.clear();\n                        dispatchInputEvent();\n                      }}\n                      onPointerDown={(e) => e.stopPropagation()}\n                      transition={{ duration: 0.3 }}\n                      type=\"button\"\n                    >\n                      <XIcon class=\"size-4 opacity-50\" />\n                    </Motion.button>\n                  </Show>\n                </Presence>\n                <ComboboxTrigger id={others.name} />\n              </>\n            )}\n          </ComboboxControl>\n          <ComboboxContent testIdSuffix={idSuffic()} />\n        </Combobox>\n        <Expandable expanded={!!props.error}>\n          <div class={cn(\"mt-1 text-red-500 text-sm\", local.errorClass)}>\n            {props.error}\n          </div>\n        </Expandable>\n      </div>\n    </>\n  );\n};\n\nexport default ModularCombobox;\n"
    },
    {
      "path": "components/modular-form/modular-date-picker.tsx",
      "type": "registry:component",
      "content": "import type { DatePickerRootProps, DateValue } from \"@ark-ui/solid/date-picker\";\nimport { getWeek, isPast, isToday, isWeekend } from \"date-fns\";\nimport { CalendarIcon, XIcon } from \"lucide-solid\";\nimport {\n  type Component,\n  type ComponentProps,\n  createMemo,\n  createSignal,\n  For,\n  Show,\n  splitProps,\n} from \"solid-js\";\nimport {\n  DatePicker,\n  DatePickerContext,\n  DatePickerNextTrigger,\n  DatePickerPrevTrigger,\n  DatePickerRangeText,\n  DatePickerTable,\n  DatePickerTableBody,\n  DatePickerTableCell,\n  DatePickerTableCellTrigger,\n  DatePickerTableHead,\n  DatePickerTableHeader,\n  DatePickerTableRow,\n  DatePickerView,\n  DatePickerViewControl,\n  DatePickerViewTrigger,\n} from \"~/components/ui/date-picker\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"~/components/ui/popover\";\nimport { useBindSignal } from \"~/hooks/use-bind-signal\";\nimport {\n  dateStringToCalendarDate,\n  formatDutchDate,\n  parseDutchDateInput,\n  toCalendarDateSafe,\n} from \"~/lib/date-utils\";\nimport { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\nimport { Button } from \"../ui/button\";\nimport { ModularLabel } from \"./modular-label\";\n\ntype ModularDatePickerProps = Component<\n  Omit<ComponentProps<\"input\">, \"value\"> & {\n    value?: number | Date;\n    label?: string;\n    error?: string;\n    name: string;\n    wrapperClass?: string;\n    labelClass?: string;\n    errorClass?: string;\n    min?: string;\n    max?: string;\n    clearButton?: boolean;\n    onDateChange?: (value: Date) => void;\n    datePickerRootProps?: DatePickerRootProps;\n    /** Show ISO week numbers column */\n    showWeekNumbers?: boolean;\n    /** Disable Saturday and Sunday */\n    disableWeekends?: boolean;\n    /** Disable dates in the past */\n    disablePast?: boolean;\n    /** Disable today's date */\n    disableToday?: boolean;\n    /** ID prefix for form compatibility */\n    prefixId?: string;\n  }\n>;\n\n/**\n * ModularDatePicker component that seamlessly converts between JavaScript Date objects\n * (used by validation libraries) and @internationalized/date CalendarDate objects\n * (used by the Ark UI DatePicker component).\n *\n * Supports Dutch date format (dd-MM-yyyy) with flexible input parsing.\n * Users can type dates like \"02022025\" or \"02-02-2025\".\n *\n * @param min - The minimum date for the date picker in the format yyyy-mm-dd\n * @param max - The maximum date for the date picker in the format yyyy-mm-dd\n * @param value - Can accept either a JavaScript Date object or number (timestamp)\n * @param onDateChange - Callback that returns a JavaScript Date object\n * @param showWeekNumbers - Show ISO week numbers in the calendar\n * @param disableWeekends - Disable Saturday and Sunday selection\n * @param disablePast - Disable past dates selection\n * @param disableToday - Disable today's date selection\n *\n * @returns A date picker component with proper type conversions\n */\nconst ModularDatePicker: ModularDatePickerProps = (props) => {\n  const [local, others] = splitProps(props, [\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"min\",\n    \"max\",\n    \"clearButton\",\n    \"label\",\n    \"class\",\n    \"error\",\n    \"onDateChange\",\n    \"datePickerRootProps\",\n    \"showWeekNumbers\",\n    \"disableWeekends\",\n    \"disablePast\",\n    \"disableToday\",\n    \"prefixId\",\n  ]);\n\n  const [value, setValue] = useBindSignal<number | Date | undefined>({\n    value: () => props.value,\n  });\n\n  const [datePickerOpen, setDatePickerOpen] = createSignal(false);\n  const [inputValue, setInputValue] = createSignal(\"\");\n  const [hasInputError, setHasInputError] = createSignal(false);\n\n  // Helper to get the Date object from the current value\n  const getDateObject = createMemo((): Date | null => {\n    const currentValue = value();\n    if (!currentValue) {\n      return null;\n    }\n\n    let dateValue: Date;\n    if (typeof currentValue === \"number\") {\n      dateValue = new Date(currentValue);\n    } else if (typeof currentValue === \"string\") {\n      dateValue = new Date(currentValue);\n    } else {\n      dateValue = currentValue;\n    }\n\n    if (Number.isNaN(dateValue.getTime())) {\n      return null;\n    }\n\n    return dateValue;\n  });\n\n  // Format for display (Dutch format: dd-MM-yyyy)\n  const getFormattedValue = createMemo(() => {\n    const dateObj = getDateObject();\n    if (!dateObj) return \"\";\n    return formatDutchDate(dateObj);\n  });\n\n  // Format for form input (ISO format: yyyy-MM-dd)\n  const getFormValueForInput = createMemo(() => {\n    const dateObj = getDateObject();\n    if (!dateObj) return \"\";\n    const year = dateObj.getFullYear();\n    const month = (dateObj.getMonth() + 1).toString().padStart(2, \"0\");\n    const day = dateObj.getDate().toString().padStart(2, \"0\");\n    return `${year}-${month}-${day}`;\n  });\n\n  // Sync input value with formatted value when value changes externally\n  const displayValue = createMemo(() => {\n    // If user is typing, show their input, otherwise show formatted value\n    const formatted = getFormattedValue();\n    if (inputValue() === \"\" && formatted) {\n      return formatted;\n    }\n    return inputValue() || formatted;\n  });\n\n  // Convert value to CalendarDate array for DatePicker\n  const getDateValue = createMemo(() => {\n    const currentValue = value();\n    if (!currentValue) return [];\n\n    const calendarDate = toCalendarDateSafe(currentValue);\n    return calendarDate ? [calendarDate] : [];\n  });\n\n  // Convert min/max strings to CalendarDate\n  const getMinDateValue = createMemo((): DateValue | undefined => {\n    if (!local.min) return;\n    try {\n      return dateStringToCalendarDate(local.min);\n    } catch {\n      return;\n    }\n  });\n\n  const getMaxDateValue = createMemo((): DateValue | undefined => {\n    if (!local.max) return;\n    try {\n      return dateStringToCalendarDate(local.max);\n    } catch {\n      return;\n    }\n  });\n\n  const inputId = () => {\n    const prefix = local.prefixId ? `${local.prefixId}-` : \"\";\n    return `${prefix}${props.name}-modular-date-picker`;\n  };\n\n  // Handle input changes (user typing)\n  const handleInputChange = (e: Event) => {\n    const target = e.target as HTMLInputElement;\n    setInputValue(target.value);\n    setHasInputError(false);\n  };\n\n  // Handle input blur - parse and validate the input\n  const handleInputBlur = () => {\n    const input = inputValue();\n\n    // If empty, clear the value\n    if (!input || input.trim() === \"\") {\n      setInputValue(\"\");\n      setHasInputError(false);\n      return;\n    }\n\n    // Try to parse the input\n    const parsedDate = parseDutchDateInput(input);\n\n    if (parsedDate) {\n      // Check against min/max constraints\n      const minDate = local.min ? new Date(local.min) : null;\n      const maxDate = local.max ? new Date(local.max) : null;\n\n      if (minDate && parsedDate < minDate) {\n        setHasInputError(true);\n        return;\n      }\n\n      if (maxDate && parsedDate > maxDate) {\n        setHasInputError(true);\n        return;\n      }\n\n      // Check disable constraints\n      if (local.disableWeekends && isWeekend(parsedDate)) {\n        setHasInputError(true);\n        return;\n      }\n\n      if (local.disablePast && isPast(parsedDate) && !isToday(parsedDate)) {\n        setHasInputError(true);\n        return;\n      }\n\n      if (local.disableToday && isToday(parsedDate)) {\n        setHasInputError(true);\n        return;\n      }\n\n      // Valid date - update the value\n      setValue(parsedDate);\n      setInputValue(formatDutchDate(parsedDate));\n      setHasInputError(false);\n      local.onDateChange?.(parsedDate);\n\n      // Dispatch input event for form libraries\n      const inputElement = document.getElementById(\n        inputId()\n      ) as HTMLInputElement;\n      if (inputElement) {\n        inputElement.dispatchEvent(\n          new Event(\"input\", { bubbles: true, composed: true })\n        );\n      }\n    } else {\n      // Invalid date - show error and revert to last valid value\n      setHasInputError(true);\n      // Revert to formatted value on next tick\n      setTimeout(() => {\n        const formatted = getFormattedValue();\n        if (formatted) {\n          setInputValue(formatted);\n          setHasInputError(false);\n        }\n      }, 1500);\n    }\n  };\n\n  // Handle date selection from picker\n  const handleValueChange = (details: {\n    value: DateValue[];\n    valueAsString: string[];\n  }) => {\n    if (details.value.length > 0 && details.value[0]) {\n      const calendarDate = details.value[0];\n      const newDate = calendarDate.toDate(\"Europe/Amsterdam\");\n\n      setValue(newDate);\n      setInputValue(formatDutchDate(newDate));\n      setHasInputError(false);\n      local.onDateChange?.(newDate);\n\n      // Dispatch input event for form libraries\n      const inputElement = document.getElementById(\n        inputId()\n      ) as HTMLInputElement;\n      if (inputElement) {\n        inputElement.dispatchEvent(\n          new Event(\"input\", { bubbles: true, composed: true })\n        );\n      }\n    }\n    setDatePickerOpen(false);\n  };\n\n  // Handle clear button\n  const handleClear = () => {\n    setValue(undefined);\n    setInputValue(\"\");\n    setHasInputError(false);\n\n    const inputElement = document.getElementById(inputId()) as HTMLInputElement;\n    if (inputElement) {\n      inputElement.dispatchEvent(\n        new Event(\"input\", { bubbles: true, composed: true })\n      );\n    }\n  };\n\n  // Check if a date should be disabled\n  const isDateDisabled = (day: DateValue): boolean => {\n    const date = day.toDate(\"Europe/Amsterdam\");\n    if (local.disableWeekends && isWeekend(date)) return true;\n    if (local.disablePast && isPast(date) && !isToday(date)) return true;\n    if (local.disableToday && isToday(date)) return true;\n    return false;\n  };\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n      <ModularLabel\n        label={local.label}\n        name={others.name}\n        required={others.required}\n      />\n      <div class=\"flex w-full space-x-0.5\">\n        <div class=\"relative w-full flex-1\">\n          {/* Hidden input for form library compatibility (receives form field props) */}\n          <input\n            {...others}\n            aria-errormessage={`${props.name}-error`}\n            aria-invalid={!!props.error}\n            class=\"sr-only\"\n            id={inputId()}\n            type=\"date\"\n            value={getFormValueForInput()}\n          />\n\n          {/* Visible text input for user interaction */}\n          <input\n            aria-invalid={!!props.error || hasInputError()}\n            class={cn(\n              \"flex h-10 w-full rounded-md border border-input bg-transparent px-3 py-2 pr-10 text-sm ring-offset-background file:border-0 file:bg-transparent file:font-medium file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n              local.class,\n              (local.error || hasInputError()) && \"!ring-red-500 ring-2\"\n            )}\n            disabled={others.disabled}\n            id={`${inputId()}-display`}\n            onBlur={handleInputBlur}\n            onInput={handleInputChange}\n            placeholder=\"dd-mm-jjjj\"\n            type=\"text\"\n            value={displayValue()}\n          />\n\n          <Popover\n            onOpenChange={setDatePickerOpen}\n            open={datePickerOpen()}\n            placement=\"bottom-end\"\n          >\n            <PopoverTrigger\n              as={Button}\n              class=\"absolute top-1/2 right-1 -translate-y-1/2 hover:bg-transparent\"\n              disabled={others.disabled}\n              id={`${inputId()}-trigger`}\n              size=\"icon\"\n              variant=\"ghost\"\n            >\n              <CalendarIcon class=\"h-4 w-4\" />\n            </PopoverTrigger>\n            <PopoverContent class=\"w-auto p-3\">\n              <DatePicker\n                {...local.datePickerRootProps}\n                closeOnSelect={false}\n                locale=\"nl-NL\"\n                max={getMaxDateValue()}\n                min={getMinDateValue()}\n                onValueChange={handleValueChange}\n                open={true}\n                startOfWeek={1}\n                timeZone=\"Europe/Amsterdam\"\n                value={getDateValue()}\n              >\n                <DatePickerView view=\"day\">\n                  <DatePickerContext>\n                    {(api) => (\n                      <>\n                        <DatePickerViewControl>\n                          <DatePickerPrevTrigger />\n                          <DatePickerViewTrigger>\n                            <DatePickerRangeText />\n                          </DatePickerViewTrigger>\n                          <DatePickerNextTrigger />\n                        </DatePickerViewControl>\n                        <DatePickerTable>\n                          <DatePickerTableHead>\n                            <DatePickerTableRow>\n                              <Show when={local.showWeekNumbers}>\n                                <DatePickerTableHeader class=\"w-6 flex-none\">\n                                  Wk\n                                </DatePickerTableHeader>\n                              </Show>\n                              <For each={api().weekDays}>\n                                {(weekDay) => (\n                                  <DatePickerTableHeader>\n                                    {weekDay.short}\n                                  </DatePickerTableHeader>\n                                )}\n                              </For>\n                            </DatePickerTableRow>\n                          </DatePickerTableHead>\n                          <DatePickerTableBody>\n                            <For each={api().weeks}>\n                              {(week) => (\n                                <DatePickerTableRow>\n                                  <Show when={local.showWeekNumbers}>\n                                    <td class=\"flex w-6 flex-none items-center justify-center font-normal text-[0.8rem] text-muted-foreground\">\n                                      {getWeek(\n                                        week[0]?.toDate(\"Europe/Amsterdam\") ??\n                                          new Date()\n                                      )}\n                                    </td>\n                                  </Show>\n                                  <For each={week}>\n                                    {(day) => (\n                                      <DatePickerTableCell\n                                        disabled={isDateDisabled(day)}\n                                        value={day}\n                                      >\n                                        <DatePickerTableCellTrigger>\n                                          {day.day}\n                                        </DatePickerTableCellTrigger>\n                                      </DatePickerTableCell>\n                                    )}\n                                  </For>\n                                </DatePickerTableRow>\n                              )}\n                            </For>\n                          </DatePickerTableBody>\n                        </DatePickerTable>\n                      </>\n                    )}\n                  </DatePickerContext>\n                </DatePickerView>\n                <DatePickerView view=\"month\">\n                  <DatePickerContext>\n                    {(api) => (\n                      <>\n                        <DatePickerViewControl>\n                          <DatePickerPrevTrigger />\n                          <DatePickerViewTrigger>\n                            <DatePickerRangeText />\n                          </DatePickerViewTrigger>\n                          <DatePickerNextTrigger />\n                        </DatePickerViewControl>\n                        <DatePickerTable>\n                          <DatePickerTableBody>\n                            <For\n                              each={api().getMonthsGrid({\n                                columns: 4,\n                                format: \"short\",\n                              })}\n                            >\n                              {(months) => (\n                                <DatePickerTableRow>\n                                  <For each={months}>\n                                    {(month) => (\n                                      <DatePickerTableCell value={month.value}>\n                                        <DatePickerTableCellTrigger>\n                                          {month.label}\n                                        </DatePickerTableCellTrigger>\n                                      </DatePickerTableCell>\n                                    )}\n                                  </For>\n                                </DatePickerTableRow>\n                              )}\n                            </For>\n                          </DatePickerTableBody>\n                        </DatePickerTable>\n                      </>\n                    )}\n                  </DatePickerContext>\n                </DatePickerView>\n                <DatePickerView view=\"year\">\n                  <DatePickerContext>\n                    {(api) => (\n                      <>\n                        <DatePickerViewControl>\n                          <DatePickerPrevTrigger />\n                          <DatePickerViewTrigger>\n                            <DatePickerRangeText />\n                          </DatePickerViewTrigger>\n                          <DatePickerNextTrigger />\n                        </DatePickerViewControl>\n                        <DatePickerTable>\n                          <DatePickerTableBody>\n                            <For each={api().getYearsGrid({ columns: 4 })}>\n                              {(years) => (\n                                <DatePickerTableRow>\n                                  <For each={years}>\n                                    {(year) => (\n                                      <DatePickerTableCell value={year.value}>\n                                        <DatePickerTableCellTrigger>\n                                          {year.label}\n                                        </DatePickerTableCellTrigger>\n                                      </DatePickerTableCell>\n                                    )}\n                                  </For>\n                                </DatePickerTableRow>\n                              )}\n                            </For>\n                          </DatePickerTableBody>\n                        </DatePickerTable>\n                      </>\n                    )}\n                  </DatePickerContext>\n                </DatePickerView>\n              </DatePicker>\n            </PopoverContent>\n          </Popover>\n        </div>\n        <Show when={local.clearButton}>\n          <Button onClick={handleClear} size=\"icon\" variant=\"ghost\">\n            <XIcon class=\"h-4 w-4\" />\n          </Button>\n        </Show>\n      </div>\n      <Expandable expanded={!!props.error}>\n        <div class={cn(\"mt-1 text-red-500 text-sm\", local.errorClass)}>\n          {props.error}\n        </div>\n      </Expandable>\n    </div>\n  );\n};\n\nexport default ModularDatePicker;\n"
    },
    {
      "path": "components/modular-form/modular-color-picker.tsx",
      "type": "registry:component",
      "content": "import type { ColorPickerValueChangeDetails } from \"@ark-ui/solid/color-picker\";\nimport { ColorPicker, parseColor } from \"@ark-ui/solid/color-picker\";\nimport type { Component, ComponentProps } from \"solid-js\";\nimport { createEffect, createSignal, For, Show, splitProps } from \"solid-js\";\nimport { cn } from \"~/lib/utils\";\nimport {\n  ColorPickerAreaBackgroundComponent,\n  ColorPickerAreaComponent,\n  ColorPickerAreaThumbComponent,\n  ColorPickerChannelSliderComponent,\n  ColorPickerChannelSliderThumbComponent,\n  ColorPickerChannelSliderTrackComponent,\n  ColorPickerContent,\n  ColorPickerControl,\n  ColorPickerHiddenInput,\n  ColorPickerInput,\n  ColorPickerPositioner,\n  ColorPickerSwatchComponent,\n  ColorPickerSwatchGroup,\n  ColorPickerSwatchIndicatorComponent,\n  ColorPickerSwatchTriggerComponent,\n  ColorPickerTransparencyGridComponent,\n  ColorPickerTrigger,\n  ColorPickerValueSwatch,\n  ColorPickerView,\n} from \"../ui/color-picker\";\nimport { ModularError } from \"./modular-error\";\nimport { ModularLabel } from \"./modular-label\";\n\ntype ModularColorPickerProps = Omit<ComponentProps<\"input\">, \"value\"> & {\n  value?: string;\n  label?: string;\n  error?: string;\n  name: string;\n  wrapperClass?: string;\n  labelClass?: string;\n  errorClass?: string;\n  placeholder?: string;\n  onValueChange?: (value: string) => void;\n  showSwatches?: boolean;\n  swatchColors?: string[];\n  format?: \"rgba\" | \"hsla\" | \"hsba\";\n  alphaDisabled?: boolean;\n};\n\nconst ModularColorPicker: Component<ModularColorPickerProps> = (props) => {\n  const [local, others] = splitProps(props, [\n    \"class\",\n    \"label\",\n    \"error\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"onValueChange\",\n    \"showSwatches\",\n    \"swatchColors\",\n    \"format\",\n    \"placeholder\",\n    \"value\",\n    \"name\",\n    \"required\",\n    \"alphaDisabled\",\n  ]);\n\n  const [colorValue, setColorValue] = createSignal(\n    local.value ? parseColor(local.value) : parseColor(\"#000000\")\n  );\n\n  // Update color when value prop changes\n  createEffect(() => {\n    if (local.value) {\n      setColorValue(parseColor(local.value));\n    }\n  });\n\n  const defaultSwatchColors = [\n    \"#ef4444\",\n    \"#f97316\",\n    \"#f59e0b\",\n    \"#84cc16\",\n    \"#10b981\",\n    \"#06b6d4\",\n    \"#3b82f6\",\n    \"#6366f1\",\n    \"#8b5cf6\",\n    \"#a855f7\",\n    \"#ec4899\",\n    \"#f43f5e\",\n  ];\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n      <ModularLabel\n        class={local.labelClass}\n        label={local.label}\n        name={local.name}\n        required={local.required}\n      />\n      <ColorPicker.Root\n        defaultValue={colorValue()}\n        format={local.format}\n        onValueChange={(details: ColorPickerValueChangeDetails) => {\n          setColorValue(details.value);\n          const hexValue = details.value.toString(\"hex\");\n          local.onValueChange?.(hexValue);\n        }}\n        value={colorValue()}\n      >\n        <ColorPickerControl\n          class={cn(\n            \"flex gap-2\",\n            local.error && \"rounded-md p-2 ring-2 ring-red-500\"\n          )}\n        >\n          <ColorPickerInput\n            channel=\"hex\"\n            class={cn(local.class, local.error && \"!ring-red-500 ring-2\")}\n            placeholder={local.placeholder ?? \"#000000\"}\n          />\n          <ColorPickerTrigger\n            aria-errormessage={`${local.name}-error`}\n            aria-invalid={!!local.error}\n          >\n            <ColorPickerTransparencyGridComponent />\n            <ColorPickerValueSwatch />\n          </ColorPickerTrigger>\n        </ColorPickerControl>\n\n        <ColorPickerPositioner>\n          <ColorPickerContent class=\"w-80\">\n            <div class=\"space-y-3\">\n              {/* Color Area */}\n              <ColorPickerAreaComponent>\n                <ColorPickerAreaBackgroundComponent />\n                <ColorPickerAreaThumbComponent />\n              </ColorPickerAreaComponent>\n\n              {/* Hue Slider */}\n              <ColorPickerChannelSliderComponent channel=\"hue\">\n                <ColorPickerChannelSliderTrackComponent />\n                <ColorPickerChannelSliderThumbComponent />\n              </ColorPickerChannelSliderComponent>\n\n              {/* Alpha Slider */}\n              <ColorPickerChannelSliderComponent channel=\"alpha\">\n                <ColorPickerTransparencyGridComponent />\n                <ColorPickerChannelSliderTrackComponent />\n                <ColorPickerChannelSliderThumbComponent />\n              </ColorPickerChannelSliderComponent>\n\n              {/* Swatches */}\n              {local.showSwatches !== false && (\n                <ColorPickerSwatchGroup class=\"flex flex-wrap gap-2\">\n                  <For each={local.swatchColors ?? defaultSwatchColors}>\n                    {(color) => (\n                      <ColorPickerSwatchTriggerComponent value={color}>\n                        <ColorPickerSwatchComponent value={color}>\n                          <ColorPickerSwatchIndicatorComponent>\n                            \n                          </ColorPickerSwatchIndicatorComponent>\n                        </ColorPickerSwatchComponent>\n                      </ColorPickerSwatchTriggerComponent>\n                    )}\n                  </For>\n                </ColorPickerSwatchGroup>\n              )}\n\n              {/* Channel Inputs */}\n              <ColorPickerView class=\"space-y-2\" format=\"rgba\">\n                <div class=\"grid grid-cols-4 gap-2\">\n                  <ColorPickerInput channel=\"red\" class=\"text-xs\" />\n                  <ColorPickerInput channel=\"green\" class=\"text-xs\" />\n                  <ColorPickerInput channel=\"blue\" class=\"text-xs\" />\n                  <Show when={!local.alphaDisabled}>\n                    <ColorPickerInput channel=\"alpha\" class=\"text-xs\" />\n                  </Show>\n                </div>\n              </ColorPickerView>\n\n              <ColorPickerView class=\"space-y-2\" format=\"hsla\">\n                <div class=\"grid grid-cols-4 gap-2\">\n                  <ColorPickerInput channel=\"hue\" class=\"text-xs\" />\n                  <ColorPickerInput channel=\"saturation\" class=\"text-xs\" />\n                  <ColorPickerInput channel=\"lightness\" class=\"text-xs\" />\n                  <Show when={!local.alphaDisabled}>\n                    <ColorPickerInput channel=\"alpha\" class=\"text-xs\" />\n                  </Show>\n                </div>\n              </ColorPickerView>\n            </div>\n          </ColorPickerContent>\n        </ColorPickerPositioner>\n\n        <ColorPickerHiddenInput {...others} name={local.name} />\n      </ColorPicker.Root>\n\n      <ModularError\n        class={local.errorClass}\n        error={local.error}\n        name={local.name}\n      />\n    </div>\n  );\n};\n\nexport default ModularColorPicker;\n"
    },
    {
      "path": "components/modular-form/modular-checkbox.tsx",
      "type": "registry:component",
      "content": "import * as CheckboxPrimitive from \"@kobalte/core/checkbox\";\nimport { type Component, type JSX, Show, splitProps } from \"solid-js\";\nimport { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\n\ntype CheckboxProps = {\n  value?: any;\n  required?: boolean | undefined;\n  disabled?: boolean | undefined;\n  defaultChecked?: boolean | undefined;\n  disableToggleLabel?: boolean | undefined;\n  ref?: (element: HTMLInputElement) => void;\n  onInput?: JSX.EventHandler<HTMLInputElement, InputEvent>;\n  onChange?: JSX.EventHandler<HTMLInputElement, Event>;\n  onBlur?: JSX.EventHandler<HTMLInputElement, FocusEvent>;\n  onCheckedChange: (checked: boolean) => void;\n  label?: string;\n  helperText?: string;\n  error?: string;\n  name: string;\n  wrapperClass?: string;\n  labelClass?: string;\n  errorClass?: string;\n};\n\nconst ModularCheckbox: Component<CheckboxProps> = (props) => {\n  const [extraProps, remainingProps] = splitProps(props, [\n    \"label\",\n    \"helperText\",\n    \"error\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n  ]);\n  const [rootProps, inputProps] = splitProps(\n    remainingProps,\n    [\"name\", \"value\", \"required\", \"disabled\"],\n    [\"ref\", \"onInput\", \"onChange\", \"onBlur\"]\n  );\n\n  return (\n    <div class={cn(extraProps.wrapperClass)}>\n      <div class=\"flex flex-row gap-x-3 space-y-0\">\n        <CheckboxPrimitive.Root\n          class={cn(\"items-top group flex space-x-2 pt-0.5\")}\n          {...rootProps}\n          checked={remainingProps?.value ?? false}\n          disabled={props.disabled}\n          onChange={(checked) => {\n            props?.onCheckedChange(checked);\n          }}\n        >\n          <CheckboxPrimitive.Input\n            id={`${rootProps.name}-modular-checkbox`}\n            {...rootProps}\n            {...inputProps}\n            disabled={props.disabled}\n            onChange={remainingProps.onChange}\n            type=\"checkbox\"\n          />\n          <CheckboxPrimitive.Control\n            class={cn(\n              \"peer size-4 shrink-0 cursor-pointer rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[checked]:border-none data-[checked]:bg-primary data-[checked]:text-primary-foreground\",\n              props.disabled && \"cursor-not-allowed opacity-50\"\n            )}\n            id={`${rootProps.name}-modular-checkbox-control`}\n          >\n            <CheckboxPrimitive.Indicator\n              id={`${rootProps.name}-modular-checkbox-indicator`}\n            >\n              <svg\n                aria-label=\"Checked\"\n                class=\"size-4\"\n                fill=\"none\"\n                role=\"img\"\n                stroke=\"currentColor\"\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                viewBox=\"0 0 24 24\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n              >\n                <path d=\"M5 12l5 5l10 -10\" />\n              </svg>\n            </CheckboxPrimitive.Indicator>\n          </CheckboxPrimitive.Control>\n        </CheckboxPrimitive.Root>\n        <div class=\"leading-none\">\n          <Show when={!!props.label}>\n            <p\n              class={cn(\n                \"font-medium text-sm\",\n                remainingProps?.onCheckedChange ? \"cursor-pointer\" : \"\",\n                props.disabled && \"cursor-not-allowed opacity-50\",\n                extraProps.labelClass\n              )}\n              onClick={() => {\n                if (\n                  remainingProps?.value !== undefined &&\n                  !props.disableToggleLabel &&\n                  !props.disabled\n                ) {\n                  remainingProps?.onCheckedChange?.(!remainingProps.value);\n                }\n              }}\n            >\n              {props.label}\n            </p>\n          </Show>\n          <Show when={!!props.helperText}>\n            <p class=\"mt-1 text-muted-foreground text-sm\">{props.helperText}</p>\n          </Show>\n        </div>\n      </div>\n      <Expandable expanded={!!extraProps.error}>\n        <div class={cn(\"mt-1 text-red-500 text-sm\", extraProps.errorClass)}>\n          {extraProps.error}\n        </div>\n      </Expandable>\n    </div>\n  );\n};\n\nexport default ModularCheckbox;\n"
    },
    {
      "path": "components/modular-form/modular-file-input-list.tsx",
      "type": "registry:component",
      "content": "import { type FormStore, remove } from \"@modular-forms/solid\";\nimport clsx from \"clsx\";\nimport { ChevronDownIcon, ChevronUpIcon, TrashIcon } from \"lucide-solid\";\nimport {\n  createEffect,\n  createMemo,\n  createSignal,\n  For,\n  type JSX,\n  Show,\n  splitProps,\n} from \"solid-js\";\nimport { useBindSignal } from \"~/hooks/use-bind-signal\";\nimport { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\nimport { Button } from \"../ui/button\";\nimport { ModularError } from \"./modular-error\";\nimport { ModularLabel } from \"./modular-label\";\n\ntype FileInputProps = {\n  ref: (element: HTMLInputElement) => void;\n  name: string;\n  value?: File[] | File;\n  onInput: JSX.EventHandler<HTMLInputElement, InputEvent>;\n  onChange: JSX.EventHandler<HTMLInputElement, Event>;\n  onBlur: JSX.EventHandler<HTMLInputElement, FocusEvent>;\n  accept?: string;\n  required?: boolean;\n  disabled?: boolean;\n  multiple?: boolean;\n  errorClass?: string;\n  labelClass?: string;\n  wrapperClass?: string;\n  formStore: FormStore<any, any>;\n  onNestedItemRemove: (index: number) => void;\n  class?: string;\n  label?: string;\n  error?: string;\n  defaultValueLabel?: string;\n};\n\n/**\n * File input field that users can click or drag files into. Various\n * decorations can be displayed in or around the field to communicate the entry\n * requirements.\n */\nexport function ModularFileInputList(props: FileInputProps) {\n  const [expanded, setExpanded] = useBindSignal({\n    value: () => false,\n  });\n\n  const [inputRef, setInputRef] = createSignal<HTMLInputElement>();\n  // Split input element props\n  const [otherProps, inputProps] = splitProps(props, [\n    \"class\",\n    \"value\",\n    \"label\",\n    \"error\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"defaultValueLabel\",\n  ]);\n\n  // Create file list\n  const getFiles = createMemo(() =>\n    props.value\n      ? Array.isArray(props.value)\n        ? props.value\n        : [props.value]\n      : []\n  );\n\n  createEffect(() => {\n    if (getFiles().length > 1) {\n      setExpanded(true);\n    }\n  });\n\n  return (\n    <div class={clsx(\"space-y-1.5\", props.wrapperClass)}>\n      <ModularLabel\n        class={props.labelClass}\n        label={props.label}\n        name={props.name}\n        required={props.required}\n      />\n      <div\n        class={clsx(\n          \"relative flex h-10 w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:font-medium file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          !getFiles().length && \"text-slate-500\",\n          inputProps.disabled\n            ? \"cursor-not-allowed opacity-50\"\n            : \"cursor-pointer\",\n          props.class\n        )}\n        onClick={() => inputRef()?.click()}\n      >\n        {otherProps.defaultValueLabel ?? (\n          <>Klik of sleep een bestand{props.multiple && \"en\"}</>\n        )}\n        <input\n          {...inputProps}\n          aria-errormessage={`${props.name}-error`}\n          aria-invalid={!!props.error}\n          class=\"absolute top-0 left-0 hidden h-full w-full opacity-0\"\n          id={props.name}\n          ref={setInputRef}\n          type=\"file\"\n        />\n      </div>\n      <Expandable expanded={getFiles().length > 1}>\n        {/* <Expandable expanded={getFiles().length > 0}> */}\n        <Button\n          class={cn(\"w-full justify-between\")}\n          onclick={() => setExpanded(!expanded())}\n          variant=\"ghost\"\n        >\n          <span> Bekijk bestanden</span>{\" \"}\n          <Show\n            fallback={<ChevronDownIcon class=\"ml-2 size-4\" />}\n            when={expanded()}\n          >\n            <ChevronUpIcon class=\"ml-2 size-4\" />\n          </Show>\n        </Button>\n        <Show when={expanded()}>\n          <hr />\n        </Show>\n      </Expandable>\n      <Expandable expanded={expanded()}>\n        <div class=\"flex max-h-[200px] flex-col gap-2 overflow-y-auto px-2\">\n          <For each={getFiles()}>\n            {(file, index) => (\n              <div class=\"flex justify-between\">\n                <span>{file.name}</span>\n                <Button\n                  onclick={() => {\n                    console.log(`remove ${props.name} at ${index()}`);\n                    remove(props.formStore, props.name, { at: index() });\n                    props.onNestedItemRemove(index());\n                  }}\n                  size=\"icon\"\n                  type=\"button\"\n                  variant=\"ghost\"\n                >\n                  <TrashIcon class=\"size-4\" />\n                </Button>\n              </div>\n            )}\n          </For>\n        </div>\n      </Expandable>\n\n      <ModularError\n        class={props.errorClass}\n        error={props.error}\n        name={props.name}\n      />\n    </div>\n  );\n}\n"
    },
    {
      "path": "components/modular-form/modular-password-update.tsx",
      "type": "registry:component",
      "content": "import { EyeIcon, EyeOffIcon } from \"lucide-solid\";\nimport type { Component, ComponentProps } from \"solid-js\";\nimport { createEffect, createSignal, Show, splitProps } from \"solid-js\";\nimport { Button } from \"~/components/ui/button\";\nimport { cn } from \"~/lib/utils\";\nimport { ModularError } from \"./modular-error\";\nimport { ModularLabel } from \"./modular-label\";\n\nconst ModularPasswordUpdate: Component<\n  ComponentProps<\"input\"> & {\n    label?: string;\n    error?: string;\n    name: string;\n    wrapperClass?: string;\n    labelClass?: string;\n    errorClass?: string;\n    isEdit?: boolean;\n    helpText?: string;\n  }\n> = (props) => {\n  const [local, others] = splitProps(props, [\n    \"class\",\n    \"label\",\n    \"error\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"isEdit\",\n    \"helpText\",\n  ]);\n\n  const [ref, setRef] = createSignal<HTMLInputElement>();\n  const [showPassword, setShowPassword] = createSignal(false);\n  const [hasBeenFocused, setHasBeenFocused] = createSignal(false);\n  const [currentValue, setCurrentValue] = createSignal(\"\");\n\n  // Set initial value for edit mode\n  createEffect(() => {\n    const inputRef = ref();\n    if (inputRef && local.isEdit && !hasBeenFocused()) {\n      inputRef.value = \"********\";\n      setCurrentValue(\"********\");\n    }\n  });\n\n  const dispatchInputEvent = () => {\n    const input = document.getElementById(\n      `${others.name}-modular-password-update`\n    ) as HTMLInputElement;\n    input.dispatchEvent(new Event(\"input\", { bubbles: true, composed: true }));\n  };\n\n  const handleFocus = () => {\n    const inputRef = ref();\n    if (inputRef && local.isEdit && !hasBeenFocused()) {\n      inputRef.value = \"\";\n      setCurrentValue(\"\");\n      setHasBeenFocused(true);\n      dispatchInputEvent();\n    }\n  };\n\n  const handleBlur = () => {\n    const inputRef = ref();\n    if (inputRef && local.isEdit && hasBeenFocused() && inputRef.value === \"\") {\n      inputRef.value = \"********\";\n      setCurrentValue(\"********\");\n      dispatchInputEvent();\n    }\n  };\n\n  const handleInput = (e: Event) => {\n    const target = e.target as HTMLInputElement;\n    setCurrentValue(target.value);\n  };\n\n  const inputId = () => `${others.name}-modular-password-update`;\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n      <ModularLabel\n        label={local.label}\n        name={inputId()}\n        required={others.required}\n      />\n      <div class=\"relative\">\n        <input\n          aria-errormessage={`${props.name}-error`}\n          aria-invalid={!!props.error}\n          class={cn(\n            \"flex h-10 w-full rounded-md border border-input bg-transparent px-3 py-2 pr-20 text-sm ring-offset-background file:border-0 file:bg-transparent file:font-medium file:text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n            local.class,\n            local.error && \"!ring-red-500 ring-2\"\n          )}\n          id={inputId()}\n          onBlur={handleBlur}\n          onFocus={handleFocus}\n          onInput={handleInput}\n          ref={setRef}\n          type={showPassword() ? \"text\" : \"password\"}\n          {...others}\n        />\n        <Button\n          class=\"absolute top-0 right-0 h-full px-3 py-2 hover:bg-transparent\"\n          disabled={others.disabled}\n          onClick={() => setShowPassword((prev) => !prev)}\n          size=\"sm\"\n          type=\"button\"\n          variant=\"ghost\"\n        >\n          <Show when={showPassword()}>\n            <EyeIcon aria-hidden=\"true\" class=\"h-4 w-4\" />\n          </Show>\n          <Show when={!showPassword()}>\n            <EyeOffIcon aria-hidden=\"true\" class=\"h-4 w-4\" />\n          </Show>\n          <span class=\"sr-only\">\n            {showPassword() ? \"Hide password\" : \"Show password\"}\n          </span>\n        </Button>\n      </div>\n      <Show when={local.helpText}>\n        <p class=\"text-muted-foreground text-sm\">{local.helpText}</p>\n      </Show>\n      <ModularError error={props.error} name={inputId()} />\n    </div>\n  );\n};\n\nexport default ModularPasswordUpdate;\n"
    },
    {
      "path": "components/modular-form/modular-label.tsx",
      "type": "registry:component",
      "content": "import { Show } from \"solid-js\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"~/components/ui/tooltip\";\nimport { cn } from \"~/lib/utils\";\n\ntype InputLabelProps = {\n  name: string;\n  label?: string;\n  required?: boolean;\n  class?: string;\n  requiredClass?: string;\n};\n\n/**\n * Input label for a form field.\n */\nexport function ModularLabel(props: InputLabelProps) {\n  return (\n    <Show when={props.label}>\n      <label\n        class={cn(\n          \"flex items-center font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\",\n          props.class\n        )}\n        for={props.name}\n      >\n        {props.label}\n\n        <Show when={props.required}>\n          <Tooltip>\n            <TooltipTrigger tabIndex={-1} type=\"button\">\n              <span\n                class={cn(\n                  \"ml-1 text-red-600 dark:text-red-400\",\n                  props.requiredClass\n                )} // Make the span not focusable\n                tabIndex={-1}\n              >\n                *\n              </span>\n            </TooltipTrigger>\n            <TooltipContent>Verplicht</TooltipContent>\n          </Tooltip>\n        </Show>\n      </label>\n    </Show>\n  );\n}\n"
    },
    {
      "path": "components/modular-form/modular-error.tsx",
      "type": "registry:component",
      "content": "import { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\n\ntype ModularErrorProps = {\n  name: string;\n  error?: string;\n  class?: string;\n};\n\n/**\n * Input error that tells the user what to do to fix the problem.\n */\nexport function ModularError(props: ModularErrorProps) {\n  return (\n    <Expandable expanded={!!props.error}>\n      <div\n        class={cn(\"mt-1 text-red-500 text-sm\", props.class)}\n        id={`${props.name}-error`}\n      >\n        {props.error}\n      </div>\n    </Expandable>\n  );\n}\n"
    },
    {
      "path": "components/modular-form/modular-forms-select.tsx",
      "type": "registry:component",
      "content": "import { XIcon } from \"lucide-solid\";\nimport {\n  type ComponentProps,\n  createEffect,\n  createMemo,\n  createSignal,\n  For,\n  on,\n  Show,\n  splitProps,\n} from \"solid-js\";\nimport {\n  Select,\n  SelectContent,\n  SelectHiddenSelect,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"~/components/ui/select\";\nimport { cn } from \"~/lib/utils\";\nimport { getColorStyles } from \"~/lib/utils/color\";\nimport { Expandable } from \"../helpers/expandable\";\nimport { SuperLabel } from \"./super-label\";\n\nexport const ModularFormsSelect = <T,>(\n  props: ComponentProps<\"select\"> & {\n    label?: string;\n    error?: string;\n    name: string;\n    options: T[];\n    placeholder?: string;\n    optionValue?: string;\n    optionTextValue?: string;\n    optionDisabled?: string;\n    optionColor?: string;\n    class?: string;\n    labelClass?: string;\n    errorClass?: string;\n    required?: boolean;\n    requiredClass?: string;\n    multiple?: boolean;\n    wrapperClass?: string;\n    \"data-testid\"?: string;\n  }\n) => {\n  const [local, others] = splitProps(props, [\n    \"label\",\n    \"error\",\n    \"class\",\n    \"labelClass\",\n    \"errorClass\",\n    \"required\",\n    \"requiredClass\",\n    \"options\",\n    \"placeholder\",\n    \"optionValue\",\n    \"optionTextValue\",\n    \"optionDisabled\",\n    \"multiple\",\n    \"wrapperClass\",\n    \"data-testid\",\n  ]);\n  const getInitialValue = () => {\n    const value = props.value;\n\n    if (local.multiple) {\n      // Handle multiple selection - value should be an array or comma-separated string\n      const values = Array.isArray(value)\n        ? value\n        : typeof value === \"string\" && value\n          ? value.split(\",\")\n          : [];\n\n      if (typeof props.options[0] === \"object\") {\n        return props.options.filter((option) =>\n          values.includes(String(option[props.optionValue as keyof T]))\n        );\n      }\n      return props.options.filter((option) => values.includes(String(option)));\n    }\n\n    // Handle single selection\n    if (typeof props.options[0] === \"object\") {\n      const res = props.options.find(\n        (option) => option[props.optionValue as keyof T] === value\n      );\n      return res;\n    }\n    const res = props.options.find((option) => option === value);\n    return res;\n  };\n\n  const [value, setValue] = createSignal<T | T[] | undefined>(\n    getInitialValue()\n  );\n\n  const isObject = createMemo(() => typeof props.options[0] === \"object\");\n\n  const itemLabel = (item: T) => {\n    if (isObject()) {\n      return <>{item[props.optionTextValue as keyof T]}</>;\n    }\n    return String(item);\n  };\n\n  const itemValue = (item: T) => {\n    if (isObject()) {\n      return String(item[props.optionValue as keyof T]);\n    }\n    return String(item);\n  };\n\n  // Ref for hidden input in multiple mode\n  let hiddenInputRef: HTMLInputElement | undefined;\n\n  // Sync external value changes (from modular-forms) to internal state\n  createEffect(\n    on(\n      () => props.value,\n      (externalValue) => {\n        if (externalValue !== undefined) {\n          (setValue as any)(getInitialValue());\n        }\n      }\n    )\n  );\n\n  // Trigger input event when value changes (for multiple mode)\n  createEffect(\n    on(value, () => {\n      if (local.multiple && hiddenInputRef) {\n        // Trigger input event to notify modular-forms\n        const event = new Event(\"input\", { bubbles: true });\n        hiddenInputRef.dispatchEvent(event);\n      }\n    })\n  );\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n      <SuperLabel\n        class={local.labelClass}\n        label={local.label}\n        name={others.name}\n        required={local.required}\n        requiredClass={local.requiredClass}\n      />\n      <Select\n        itemComponent={(itemProps) => (\n          <SelectItem item={itemProps.item}>\n            {itemLabel(itemProps.item.rawValue as T)}\n          </SelectItem>\n        )}\n        multiple={local.multiple}\n        name={props.name}\n        onChange={setValue as any}\n        optionDisabled={props.optionDisabled as any}\n        options={props.options}\n        optionTextValue={props.optionTextValue as any}\n        optionValue={props.optionValue as any}\n        placeholder={props.placeholder || \"Select an option...\"}\n        value={value() as any}\n      >\n        <Show\n          fallback={\n            // For multiple selection, use comma-separated values\n            <input\n              {...(others as ComponentProps<\"input\">)}\n              ref={hiddenInputRef}\n              type=\"hidden\"\n              value={((value() as T[]) || [])\n                .map((item) => itemValue(item))\n                .join(\",\")}\n            />\n          }\n          when={!local.multiple}\n        >\n          <SelectHiddenSelect {...others} />\n        </Show>\n        <SelectTrigger\n          aria-label={props.label || props.name}\n          class={cn(\n            \"w-full\",\n            local.multiple && \"h-auto min-h-10 py-2\",\n            local.class\n          )}\n          data-testid={local[\"data-testid\"]}\n        >\n          <SelectValue<T>\n            class={cn(\n              \"w-full text-left\",\n              others.value === \"\" && \"text-muted-foreground\"\n            )}\n          >\n            {(state) => {\n              if (local.multiple) {\n                const selectedOptions = state.selectedOptions() as T[];\n                return (\n                  <Show when={selectedOptions.length > 0}>\n                    <div class=\"flex flex-wrap gap-1\">\n                      <For each={selectedOptions}>\n                        {(option) => {\n                          const colorValue =\n                            option[props.optionColor as keyof T];\n                          const colorStyles =\n                            colorValue && typeof colorValue === \"string\"\n                              ? getColorStyles(colorValue)\n                              : undefined;\n                          const hasValidColor = !!colorStyles;\n\n                          return (\n                            <span\n                              class={cn(\n                                \"inline-flex items-center gap-1 rounded-md px-2 py-0.5 text-sm\",\n                                !hasValidColor && \"bg-primary/10 text-primary\"\n                              )}\n                              onPointerDown={(e) => e.stopPropagation()}\n                              style={colorStyles}\n                            >\n                              {itemLabel(option)}\n                              <button\n                                aria-label={`Remove ${itemLabel(option)}`}\n                                class=\"rounded-sm p-0.5 hover:bg-primary/20\"\n                                onClick={(e) => {\n                                  e.stopPropagation();\n                                  state.remove(option);\n                                }}\n                                type=\"button\"\n                              >\n                                <XIcon class=\"size-4\" />\n                              </button>\n                            </span>\n                          );\n                        }}\n                      </For>\n                    </div>\n                  </Show>\n                );\n              }\n              return itemLabel(state.selectedOption() as T);\n            }}\n          </SelectValue>\n          <Show when={local.multiple && (value() as T[])?.length > 0}>\n            <button\n              aria-label=\"Clear all selections\"\n              class=\"rounded-sm p-1 hover:bg-muted\"\n              onClick={(e) => {\n                e.stopPropagation();\n                (setValue as any)([] as T[]);\n              }}\n              onPointerDown={(e) => e.stopPropagation()}\n              type=\"button\"\n            >\n              <XIcon class=\"size-4\" />\n            </button>\n          </Show>\n        </SelectTrigger>\n        <SelectContent />\n      </Select>\n      <Expandable expanded={!!props.error}>\n        <div\n          class={cn(\"mt-1 text-red-500 text-sm\", local.errorClass)}\n          id={`${others.name}-error`}\n        >\n          {local.error}\n        </div>\n      </Expandable>\n    </div>\n  );\n};\n"
    },
    {
      "path": "components/modular-form/modular-forms-combobox.tsx",
      "type": "registry:component",
      "content": "import debounce from \"debounce\";\nimport {\n  type ComponentProps,\n  createEffect,\n  createMemo,\n  createSignal,\n  on,\n  splitProps,\n} from \"solid-js\";\nimport { cn } from \"~/lib/utils\";\nimport { Expandable } from \"../helpers/expandable\";\nimport {\n  Combobox,\n  ComboboxContent,\n  ComboboxControl,\n  ComboboxHiddenSelect,\n  ComboboxInput,\n  ComboboxItem,\n  ComboboxItemIndicator,\n  ComboboxItemLabel,\n  ComboboxTrigger,\n} from \"../ui/combobox\";\nimport { SuperLabel } from \"./super-label\";\n\nexport const ModularFormsCombobox = <T,>(\n  props: ComponentProps<\"select\"> & {\n    label?: string;\n    error?: string;\n    name: string;\n    options: T[];\n    placeholder?: string;\n    optionValue?: string;\n    optionTextValue?: string;\n    optionDisabled?: string;\n    class?: string;\n    labelClass?: string;\n    errorClass?: string;\n    required?: boolean;\n    requiredClass?: string;\n    multiple?: boolean;\n    wrapperClass?: string;\n    onInputOverride?: (value: string) => void;\n    disableFilter?: boolean;\n  }\n) => {\n  const [local, others] = splitProps(props, [\n    \"label\",\n    \"error\",\n    \"class\",\n    \"labelClass\",\n    \"errorClass\",\n    \"required\",\n    \"requiredClass\",\n    \"options\",\n    \"placeholder\",\n    \"optionValue\",\n    \"optionTextValue\",\n    \"optionDisabled\",\n    \"multiple\",\n    \"wrapperClass\",\n    \"onInputOverride\",\n    \"disableFilter\",\n  ]);\n  const getInitialValue = () => {\n    const value = props.value;\n\n    if (local.multiple) {\n      // Handle multiple selection - value should be an array or comma-separated string\n      const values = Array.isArray(value)\n        ? value\n        : typeof value === \"string\" && value\n          ? value.split(\",\")\n          : [];\n\n      if (typeof props.options[0] === \"object\") {\n        return props.options.filter((option) =>\n          values.includes(String(option[props.optionValue as keyof T]))\n        );\n      }\n      return props.options.filter((option) => values.includes(String(option)));\n    }\n\n    // Handle single selection\n    if (typeof props.options[0] === \"object\") {\n      const res = props.options.find(\n        (option) => option[props.optionValue as keyof T] === value\n      );\n      return res;\n    }\n    const res = props.options.find((option) => option === value);\n    return res;\n  };\n\n  const [value, setValue] = createSignal<T | T[] | null>(\n    getInitialValue() ?? null\n  );\n\n  const isObject = createMemo(() => typeof props.options[0] === \"object\");\n\n  const itemLabel = (item: T) => {\n    if (!item) return \"\";\n\n    if (isObject()) {\n      return String(item[props.optionTextValue as keyof T]);\n    }\n    return String(item);\n  };\n\n  const itemValue = (item: T) => {\n    if (!item) return null;\n\n    if (isObject()) {\n      return String(item[props.optionValue as keyof T]);\n    }\n    return String(item);\n  };\n\n  // Ref for hidden input in multiple mode\n  let hiddenInputRef: HTMLInputElement | undefined;\n\n  // // Sync external value changes (from modular-forms) to internal state\n  // createEffect(\n  // \ton(\n  // \t\t() => props.value,\n  // \t\t(externalValue) => {\n  // \t\t\tif (externalValue !== undefined) {\n  // \t\t\t\t(setValue as any)(getInitialValue());\n  // \t\t\t}\n  // \t\t},\n  // \t),\n  // );\n\n  // Trigger input event when value changes (for multiple mode)\n  createEffect(\n    on(value, (value) => {\n      console.log(\"[value] value\", value);\n      if (value) {\n        console.log(\"[value] value\", value);\n        setInputValue(itemLabel(value as T));\n      }\n      // if (local.multiple && hiddenInputRef) {\n      // \t// Trigger input event to notify modular-forms\n      // \tconst event = new Event(\"input\", { bubbles: true });\n      // \thiddenInputRef.dispatchEvent(event);\n      // }\n    })\n  );\n\n  /**\n   * Input override vars\n   */\n  const [inputValue, setInputValue] = createSignal(\"\");\n  const [query, setQuery] = createSignal(\"\");\n  const [debouncedQuery, setDebouncedQuery] = createSignal(\"\");\n\n  // Create debounced function with 500ms delay\n  const debouncedSetQuery = debounce((value: string) => {\n    setDebouncedQuery(value);\n  }, 500);\n\n  // Update debounced query when query changes\n  createEffect(\n    on(query, (value) => {\n      console.log(\"[query] value\", value);\n      debouncedSetQuery(value);\n      if (value === \"\") {\n        setValue(null);\n      }\n    })\n  );\n\n  createEffect(\n    on(debouncedQuery, (value) => {\n      local.onInputOverride?.(value);\n    })\n  );\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n      <SuperLabel\n        class={local.labelClass}\n        label={local.label}\n        name={others.name}\n        required={local.required}\n        requiredClass={local.requiredClass}\n      />\n      <Combobox\n        defaultFilter={local.disableFilter ? () => true : undefined}\n        itemComponent={(props) => (\n          <ComboboxItem item={props.item}>\n            <ComboboxItemLabel>\n              {itemLabel(props.item.rawValue as T)}\n            </ComboboxItemLabel>\n            <ComboboxItemIndicator />\n          </ComboboxItem>\n        )}\n        name={props.name}\n        onChange={(newValue) => {\n          console.log(\"[onChange] value\", newValue);\n          if (value() !== null && newValue === null) {\n            setInputValue(\"\");\n          }\n          setValue((newValue as any) ?? null);\n        }}\n        onInputChange={(value) => {\n          if (typeof value === \"string\" && value !== \"[object Object]\") {\n            setQuery(value);\n          }\n        }}\n        optionDisabled={props.optionDisabled as any}\n        optionLabel={props.optionTextValue as any}\n        options={props.options}\n        optionTextValue={props.optionTextValue as any}\n        optionValue={props.optionValue as any}\n        placeholder={props.placeholder || \"Select an option...\"}\n        value={value() as any}\n      >\n        <ComboboxHiddenSelect {...others} />\n        <ComboboxControl aria-label=\"Fruit\">\n          <ComboboxInput\n            onInput={(e) => {\n              console.log(\n                \"[onInput] value\",\n                (e.target as HTMLInputElement).value\n              );\n              setInputValue((e.target as HTMLInputElement).value);\n            }}\n            value={inputValue()}\n          />\n          <ComboboxTrigger />\n        </ComboboxControl>\n        <ComboboxContent />\n      </Combobox>\n      <Expandable expanded={!!props.error}>\n        <div\n          class={cn(\"mt-1 text-red-500 text-sm\", local.errorClass)}\n          id={`${others.name}-error`}\n        >\n          {local.error}\n        </div>\n      </Expandable>\n    </div>\n  );\n};\n"
    },
    {
      "path": "components/modular-form/modular-forms-toggle-button.tsx",
      "type": "registry:component",
      "content": "import * as ButtonPrimitive from \"@kobalte/core/button\";\nimport { type Component, type JSX, Show, splitProps } from \"solid-js\";\nimport { cn } from \"~/lib/utils\";\nimport { SuperError } from \"./super-error\";\nimport { SuperLabel } from \"./super-label\";\n\ntype ToggleButtonProps = {\n  value?: boolean;\n  required?: boolean | undefined;\n  disabled?: boolean | undefined;\n  defaultPressed?: boolean | undefined;\n  ref?: (element: HTMLInputElement) => void;\n  onInput?: JSX.EventHandler<HTMLInputElement, InputEvent>;\n  onChange?: JSX.EventHandler<HTMLInputElement, Event>;\n  onBlur?: JSX.EventHandler<HTMLInputElement, FocusEvent>;\n  onPressedChange: (pressed: boolean) => void;\n  label?: string;\n  helperText?: string;\n  error?: string;\n  name: string;\n  wrapperClass?: string;\n  labelClass?: string;\n  errorClass?: string;\n  variant?: \"default\" | \"outline\" | \"ghost\" | \"secondary\";\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n  text?: string;\n  icon?: Component<JSX.IntrinsicElements[\"svg\"]>;\n  children?: JSX.Element;\n  selectedColor?: string;\n};\n\nconst ModularFormsToggleButton: Component<ToggleButtonProps> = (props) => {\n  const [extraProps, remainingProps] = splitProps(props, [\n    \"label\",\n    \"helperText\",\n    \"error\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"variant\",\n    \"size\",\n    \"text\",\n    \"icon\",\n    \"children\",\n    \"selectedColor\",\n  ]);\n  const [rootProps, inputProps] = splitProps(\n    remainingProps,\n    [\"name\", \"value\", \"required\", \"disabled\"],\n    [\"ref\", \"onInput\", \"onChange\", \"onBlur\"]\n  );\n\n  const isPressed = () => remainingProps?.value ?? false;\n  const inputId = () => `${rootProps.name}-toggle-button-input`;\n\n  const buttonVariantClasses = () => {\n    const base =\n      \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md font-medium text-sm ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\";\n\n    const variant = extraProps.variant ?? \"outline\";\n    const size = extraProps.size ?? \"default\";\n\n    const variantClasses = {\n      default: isPressed()\n        ? \"bg-primary text-primary-foreground hover:bg-primary/90\"\n        : \"bg-background text-foreground hover:bg-accent hover:text-accent-foreground\",\n      outline: isPressed()\n        ? \"border border-primary bg-primary text-primary-foreground hover:bg-primary/90\"\n        : \"border border-input hover:bg-accent hover:text-accent-foreground\",\n      ghost: isPressed()\n        ? \"bg-accent text-accent-foreground\"\n        : \"hover:bg-accent hover:text-accent-foreground\",\n      secondary: isPressed()\n        ? \"bg-secondary text-secondary-foreground hover:bg-secondary/80\"\n        : \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n    };\n\n    const sizeClasses = {\n      default: \"h-10 px-4 py-2\",\n      sm: \"h-9 px-3 text-xs\",\n      lg: \"h-11 px-8\",\n      icon: \"size-10\",\n    };\n\n    return cn(base, variantClasses[variant], sizeClasses[size]);\n  };\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", extraProps.wrapperClass)}>\n      <SuperLabel\n        class={extraProps.labelClass}\n        label={extraProps.label}\n        name={inputId()}\n        required={rootProps.required}\n      />\n      <div class=\"flex flex-col gap-1\">\n        <input\n          {...inputProps}\n          checked={isPressed()}\n          class=\"sr-only\"\n          disabled={props.disabled}\n          id={inputId()}\n          name={rootProps.name}\n          onChange={(e) => {\n            const checked = (e.target as HTMLInputElement).checked;\n            remainingProps?.onPressedChange?.(checked);\n            inputProps.onChange?.(e);\n          }}\n          required={rootProps.required}\n          type=\"checkbox\"\n        />\n        <ButtonPrimitive.Root\n          aria-errormessage={props.error ? `${inputId()}-error` : undefined}\n          aria-invalid={!!props.error}\n          aria-pressed={isPressed()}\n          class={cn(\n            buttonVariantClasses(),\n            props.error && \"!ring-red-500 ring-2\",\n            props.disabled && \"cursor-not-allowed opacity-50\"\n          )}\n          data-pressed={isPressed()}\n          disabled={props.disabled}\n          onClick={() => {\n            if (!props.disabled) {\n              const newValue = !isPressed();\n              remainingProps?.onPressedChange?.(newValue);\n              // Trigger change event on hidden input for modular forms\n              const input = document.getElementById(\n                inputId()\n              ) as HTMLInputElement;\n              if (input) {\n                input.checked = newValue;\n                input.dispatchEvent(new Event(\"change\", { bubbles: true }));\n              }\n            }\n          }}\n          style={\n            extraProps.selectedColor && isPressed()\n              ? { \"background-color\": extraProps.selectedColor }\n              : undefined\n          }\n          type=\"button\"\n        >\n          {extraProps.children ? (\n            extraProps.children\n          ) : (\n            <>\n              {extraProps.icon && (\n                <extraProps.icon\n                  class={cn(\n                    \"size-4 shrink-0\",\n                    extraProps.text && extraProps.size !== \"icon\" && \"mr-2\"\n                  )}\n                />\n              )}\n              {extraProps.text && <span>{extraProps.text}</span>}\n            </>\n          )}\n        </ButtonPrimitive.Root>\n        <Show when={!!extraProps.helperText}>\n          <p class=\"text-muted-foreground text-sm\">{extraProps.helperText}</p>\n        </Show>\n      </div>\n      <SuperError\n        class={extraProps.errorClass}\n        error={extraProps.error}\n        name={inputId()}\n      />\n    </div>\n  );\n};\n\nexport default ModularFormsToggleButton;\n"
    },
    {
      "path": "components/modular-form/modular-forms-toggle-button-group.tsx",
      "type": "registry:component",
      "content": "import * as ButtonPrimitive from \"@kobalte/core/button\";\nimport {\n  type Component,\n  type ComponentProps,\n  createEffect,\n  For,\n  on,\n  splitProps,\n} from \"solid-js\";\nimport { cn } from \"~/lib/utils\";\nimport { SuperError } from \"./super-error\";\nimport { SuperLabel } from \"./super-label\";\n\ntype ToggleButtonOption = {\n  label?: string;\n  labelIcon?: Component<JSX.IntrinsicElements[\"svg\"]>;\n  value: string | number | boolean;\n  selectedColor?: string;\n};\n\ntype ToggleButtonGroupProps = ComponentProps<\"input\"> & {\n  label?: string;\n  error?: string;\n  name: string;\n  options: ToggleButtonOption[];\n  value?: (string | number | boolean)[];\n  required?: boolean | undefined;\n  disabled?: boolean | undefined;\n  onValueChange: (value: (string | number | boolean)[]) => void;\n  wrapperClass?: string;\n  labelClass?: string;\n  errorClass?: string;\n  variant?: \"default\" | \"outline\" | \"ghost\" | \"secondary\";\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n  orientation?: \"horizontal\" | \"vertical\";\n  ref?: (element: HTMLInputElement) => void;\n  onInput?: ComponentProps<\"input\">[\"onInput\"];\n  onChange?: ComponentProps<\"input\">[\"onChange\"];\n  onBlur?: ComponentProps<\"input\">[\"onBlur\"];\n};\n\nconst ModularFormsToggleButtonGroup: Component<ToggleButtonGroupProps> = (\n  props\n) => {\n  const [local, others] = splitProps(props, [\n    \"label\",\n    \"error\",\n    \"options\",\n    \"value\",\n    \"required\",\n    \"disabled\",\n    \"onValueChange\",\n    \"wrapperClass\",\n    \"labelClass\",\n    \"errorClass\",\n    \"variant\",\n    \"size\",\n    \"orientation\",\n  ]);\n\n  const [inputProps] = splitProps(others, [\n    \"ref\",\n    \"onInput\",\n    \"onChange\",\n    \"onBlur\",\n  ]);\n\n  // Ref for hidden input\n  let hiddenInputRef: HTMLInputElement | undefined;\n\n  const isSelected = (optionValue: string | number | boolean) => {\n    if (!local.value || local.value.length === 0) return false;\n    // Check if the option value is in the array (with type coercion)\n    return local.value.some(\n      (val) => val === optionValue || String(val) === String(optionValue)\n    );\n  };\n\n  const inputId = () => `${others.name}-toggle-button-group-input`;\n  const groupId = () => `${others.name}-toggle-button-group`;\n\n  // Sync value prop with hidden input (comma-separated for modular forms)\n  createEffect(\n    on(\n      () => local.value,\n      (values) => {\n        if (!hiddenInputRef) return;\n        const valueString = (values ?? []).map(String).join(\",\");\n        // Only update if the value is actually different to prevent loops\n        if (hiddenInputRef.value !== valueString) {\n          hiddenInputRef.value = valueString;\n          // Trigger input event to notify modular forms\n          const event = new Event(\"input\", { bubbles: true });\n          hiddenInputRef.dispatchEvent(event);\n        }\n      }\n    )\n  );\n\n  const buttonVariantClasses = (isPressed: boolean) => {\n    const base =\n      \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md font-medium text-sm ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\";\n\n    const variant = local.variant ?? \"outline\";\n    const size = local.size ?? \"default\";\n\n    const variantClasses = {\n      default: isPressed\n        ? \"bg-primary text-primary-foreground hover:bg-primary/90\"\n        : \"bg-background text-foreground hover:bg-accent hover:text-accent-foreground\",\n      outline: isPressed\n        ? \"border border-primary bg-primary text-primary-foreground hover:bg-primary/90\"\n        : \"border border-input hover:bg-accent hover:text-accent-foreground\",\n      ghost: isPressed\n        ? \"bg-accent text-accent-foreground\"\n        : \"hover:bg-accent hover:text-accent-foreground\",\n      secondary: isPressed\n        ? \"bg-secondary text-secondary-foreground hover:bg-secondary/80\"\n        : \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n    };\n\n    const sizeClasses = {\n      default: \"h-10 px-4 py-2\",\n      sm: \"h-9 px-3 text-xs\",\n      lg: \"h-11 px-8\",\n      icon: \"size-10\",\n    };\n\n    return cn(base, variantClasses[variant], sizeClasses[size]);\n  };\n\n  const handleButtonClick = (optionValue: string | number | boolean) => {\n    if (!local.disabled) {\n      const currentValues = local.value ?? [];\n      const isCurrentlySelected = isSelected(optionValue);\n\n      // Toggle the value: remove if present, add if not present\n      const newValues = isCurrentlySelected\n        ? currentValues.filter(\n            (val) => val !== optionValue && String(val) !== String(optionValue)\n          )\n        : [...currentValues, optionValue];\n\n      local.onValueChange(newValues);\n      // The createEffect will handle syncing the hidden input and triggering events\n    }\n  };\n\n  return (\n    <div class={cn(\"w-full items-center space-y-1.5\", local.wrapperClass)}>\n      <SuperLabel\n        class={local.labelClass}\n        label={local.label}\n        name={inputId()}\n        required={local.required}\n      />\n      <div class=\"flex flex-col gap-1\">\n        {/* Hidden input for modular forms - comma-separated values for arrays */}\n        <input\n          {...inputProps}\n          class=\"sr-only\"\n          disabled={local.disabled}\n          id={inputId()}\n          name={others.name}\n          onChange={(e) => {\n            // Only call the original onChange handler, don't update our state\n            // The hidden input is read-only from modular forms' perspective\n            inputProps.onChange?.(e);\n          }}\n          ref={hiddenInputRef}\n          required={local.required}\n          type=\"hidden\"\n          value={(local.value ?? []).map(String).join(\",\")}\n        />\n        <div\n          aria-label={local.label}\n          class={cn(\n            \"inline-flex overflow-auto\",\n            local.orientation === \"vertical\" ? \"flex-col\" : \"flex-row\",\n            \"[&>button]:rounded-none\",\n            \"[&>button:first-child]:rounded-l-md\",\n            \"[&>button:last-child]:rounded-r-md\",\n            local.orientation === \"vertical\" &&\n              \"[&>button:first-child]:rounded-t-md\",\n            local.orientation === \"vertical\" &&\n              \"[&>button:last-child]:rounded-b-md\",\n            local.orientation === \"vertical\" &&\n              \"[&>button:not(:last-child)]:rounded-b-none\",\n            local.orientation === \"vertical\" &&\n              \"[&>button:not(:first-child)]:rounded-t-none\",\n            local.orientation === \"horizontal\" &&\n              \"[&>button:not(:last-child)]:rounded-r-none\",\n            local.orientation === \"horizontal\" &&\n              \"[&>button:not(:first-child)]:rounded-l-none\"\n          )}\n          id={groupId()}\n          role=\"group\"\n        >\n          <For each={local.options}>\n            {(option) => {\n              const pressed = () => isSelected(option.value);\n              return (\n                <ButtonPrimitive.Root\n                  aria-pressed={pressed()}\n                  class={cn(\n                    buttonVariantClasses(pressed()),\n                    local.error && \"!ring-red-500 ring-2\",\n                    local.disabled && \"cursor-not-allowed opacity-50\"\n                  )}\n                  data-pressed={pressed()}\n                  disabled={local.disabled}\n                  onClick={() => handleButtonClick(option.value)}\n                  style={\n                    option.selectedColor && pressed()\n                      ? {\n                          \"background-color\": option.selectedColor,\n                          \"border-color\": option.selectedColor,\n                        }\n                      : undefined\n                  }\n                  type=\"button\"\n                >\n                  {/* labelIcon takes precedence - if present, show only icon */}\n                  {option.labelIcon ? (\n                    <option.labelIcon class=\"size-4 shrink-0\" />\n                  ) : (\n                    /* Otherwise show label if present, or fall back to value */\n                    <span>{option.label ?? String(option.value)}</span>\n                  )}\n                </ButtonPrimitive.Root>\n              );\n            }}\n          </For>\n        </div>\n      </div>\n      <SuperError\n        class={local.errorClass}\n        error={local.error}\n        name={inputId()}\n      />\n    </div>\n  );\n};\n\nexport default ModularFormsToggleButtonGroup;\n"
    }
  ]
}
