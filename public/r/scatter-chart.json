{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "scatter-chart",
  "type": "registry:chart",
  "title": "Scatter Chart",
  "description": "D3-powered scatter plot component with multiple series support, tooltips, and responsive sizing",
  "dependencies": ["d3"],
  "registryDependencies": ["chart-utils"],
  "files": [
    {
      "path": "components/charts/scatter-chart.tsx",
      "type": "registry:chart",
      "content": "import { select } from \"d3\";\nimport {\n  type Component,\n  createEffect,\n  createMemo,\n  For,\n  on,\n  onMount,\n  Show,\n} from \"solid-js\";\nimport {\n  type ChartMargin,\n  calculateDimensions,\n  chartStyles,\n  computeNumericExtent,\n  computeTimeExtent,\n  createAxisGenerator,\n  createColorScale,\n  createLinearScale,\n  createTimeScale,\n  defaultColorPalette,\n  getColorFromPalette,\n  getRelativeMousePosition,\n  renderAxis,\n  styleAxis,\n  styleGridLines,\n  useChartTooltip,\n  useResizeObserver,\n} from \"~/lib/charts\";\n\nexport type ScatterDataPoint = {\n  x: Date | number;\n  y: number;\n  label?: string;\n  size?: number;\n};\n\nexport type ScatterSeries = {\n  id: string;\n  name: string;\n  data: ScatterDataPoint[];\n  color?: string;\n};\n\nexport type ScatterChartProps = {\n  data: ScatterSeries[];\n  width?: number;\n  height?: number;\n  margin?: Partial<ChartMargin>;\n  xAxisLabel?: string;\n  yAxisLabel?: string;\n  showGrid?: boolean;\n  showLegend?: boolean;\n  pointRadius?: number;\n  pointOpacity?: number;\n  colors?: readonly string[];\n  class?: string;\n};\n\ntype TooltipContent = {\n  x: Date | number;\n  y: number;\n  seriesName: string;\n  seriesId: string;\n  color: string;\n  label?: string;\n};\n\ntype FindClosestOptions = {\n  data: ScatterSeries[];\n  adjustedX: number;\n  adjustedY: number;\n  xScale: (v: number | Date) => number;\n  yScale: (v: number) => number;\n  getSeriesColor: (series: ScatterSeries, index: number) => string;\n  pointRadius: number;\n};\n\nconst findClosestDataPoint = (\n  options: FindClosestOptions\n): TooltipContent | null => {\n  const {\n    data,\n    adjustedX,\n    adjustedY,\n    xScale,\n    yScale,\n    getSeriesColor,\n    pointRadius,\n  } = options;\n  let closest: TooltipContent | null = null;\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  // For scatter plots, check all points and find the one closest to the cursor\n  for (let seriesIndex = 0; seriesIndex < data.length; seriesIndex++) {\n    const series = data[seriesIndex];\n\n    for (const point of series.data) {\n      const px = xScale(point.x as number & Date);\n      const py = yScale(point.y);\n      const distance = Math.sqrt((px - adjustedX) ** 2 + (py - adjustedY) ** 2);\n\n      // Use point radius + buffer for hit detection\n      const hitRadius = (point.size ?? pointRadius) + 10;\n      if (distance < minDistance && distance < hitRadius) {\n        minDistance = distance;\n        closest = {\n          x: point.x,\n          y: point.y,\n          seriesName: series.name,\n          seriesId: series.id,\n          color: getSeriesColor(series, seriesIndex),\n          label: point.label,\n        };\n      }\n    }\n  }\n\n  return closest;\n};\n\nexport const ScatterChart: Component<ScatterChartProps> = (props) => {\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let containerRef: HTMLDivElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let svgRef: SVGSVGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let xAxisRef: SVGGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let yAxisRef: SVGGElement | undefined;\n  // biome-ignore lint/suspicious/noUnassignedVariables: SolidJS ref pattern\n  let gridRef: SVGGElement | undefined;\n\n  const tooltip = useChartTooltip<TooltipContent>();\n\n  const containerSize = useResizeObserver(() => containerRef, {\n    debounceMs: 100,\n  });\n\n  const dimensions = createMemo(() => {\n    const width = props.width ?? containerSize().width;\n    const height = props.height ?? containerSize().height ?? 300;\n    return calculateDimensions(width, height, props.margin);\n  });\n\n  const colorScale = createMemo(() => {\n    const seriesIds = props.data.map((s) => s.id);\n    const colors = props.colors ?? defaultColorPalette;\n    return createColorScale(seriesIds, colors);\n  });\n\n  const isTimeScale = createMemo(() => {\n    const firstSeries = props.data[0];\n    if (!firstSeries?.data[0]) {\n      return false;\n    }\n    return firstSeries.data[0].x instanceof Date;\n  });\n\n  const xScale = createMemo(() => {\n    const { innerWidth } = dimensions();\n    const allXValues = props.data.flatMap((s) => s.data.map((d) => d.x));\n\n    if (isTimeScale()) {\n      const extent = computeTimeExtent(allXValues as Date[]);\n      return createTimeScale(extent, [0, innerWidth], { nice: true });\n    }\n\n    const extent = computeNumericExtent(allXValues as number[], 0.05);\n    return createLinearScale(extent, [0, innerWidth], { nice: true });\n  });\n\n  const yScale = createMemo(() => {\n    const { innerHeight } = dimensions();\n    const allYValues = props.data.flatMap((s) => s.data.map((d) => d.y));\n    const extent = computeNumericExtent(allYValues, 0.1);\n    const minY = Math.min(0, extent[0]);\n    return createLinearScale([minY, extent[1]], [innerHeight, 0], {\n      nice: true,\n    });\n  });\n\n  const getSeriesColor = (series: ScatterSeries, index: number): string => {\n    if (series.color) {\n      return series.color;\n    }\n    return (\n      colorScale()(series.id) ??\n      getColorFromPalette(index, props.colors ?? defaultColorPalette)\n    );\n  };\n\n  onMount(() => {\n    if (xAxisRef && yAxisRef) {\n      updateAxes();\n    }\n  });\n\n  const updateAxes = () => {\n    const { innerWidth, innerHeight } = dimensions();\n\n    if (xAxisRef) {\n      const xAxis = createAxisGenerator(\"bottom\", xScale(), {\n        tickCount: Math.floor(innerWidth / 80),\n      });\n      renderAxis(xAxisRef, xAxis);\n      styleAxis(xAxisRef);\n    }\n\n    if (yAxisRef) {\n      const yAxis = createAxisGenerator(\"left\", yScale(), {\n        tickCount: Math.floor(innerHeight / 50),\n      });\n      renderAxis(yAxisRef, yAxis);\n      styleAxis(yAxisRef);\n    }\n\n    if (gridRef && props.showGrid !== false) {\n      const gridAxis = createAxisGenerator(\"left\", yScale(), {\n        tickCount: Math.floor(innerHeight / 50),\n        tickSize: -innerWidth,\n      });\n      select(gridRef).call(gridAxis);\n      styleGridLines(gridRef);\n    }\n  };\n\n  createEffect(\n    on([dimensions, xScale, yScale], () => {\n      updateAxes();\n    })\n  );\n\n  const handleMouseMove = (event: MouseEvent) => {\n    if (!svgRef) {\n      return;\n    }\n\n    const { margin } = dimensions();\n    const mousePos = getRelativeMousePosition(event, svgRef);\n    const adjustedX = mousePos.x - margin.left;\n    const adjustedY = mousePos.y - margin.top;\n\n    const closest = findClosestDataPoint({\n      data: props.data,\n      adjustedX,\n      adjustedY,\n      xScale: xScale(),\n      yScale: yScale(),\n      getSeriesColor,\n      pointRadius: props.pointRadius ?? 6,\n    });\n\n    if (closest) {\n      tooltip.show(closest, { x: mousePos.x, y: mousePos.y });\n    } else {\n      tooltip.hide();\n    }\n  };\n\n  const handleMouseLeave = () => {\n    tooltip.hide();\n  };\n\n  const formatTooltipX = (x: Date | number | undefined): string => {\n    if (x === undefined) {\n      return \"\";\n    }\n    if (x instanceof Date) {\n      return x.toLocaleDateString(undefined, {\n        month: \"short\",\n        day: \"numeric\",\n        year: \"numeric\",\n      });\n    }\n    return x.toLocaleString(undefined, { maximumFractionDigits: 2 });\n  };\n\n  const formatTooltipY = (y: number | undefined): string => {\n    if (y === undefined) {\n      return \"\";\n    }\n    return y.toLocaleString(undefined, {\n      maximumFractionDigits: 2,\n    });\n  };\n\n  return (\n    <div\n      class={`relative w-full ${props.class ?? \"\"}`}\n      ref={containerRef}\n      style={{ \"min-height\": `${props.height ?? 300}px` }}\n    >\n      <Show when={dimensions().width > 0 && dimensions().height > 0}>\n        {/* biome-ignore lint/a11y/noSvgWithoutTitle: Chart with programmatic tooltip */}\n        {/* biome-ignore lint/a11y/noNoninteractiveElementInteractions: Chart interaction */}\n        <svg\n          class=\"select-none\"\n          height={dimensions().height}\n          onMouseLeave={handleMouseLeave}\n          onMouseMove={handleMouseMove}\n          ref={svgRef}\n          width={dimensions().width}\n        >\n          <g\n            transform={`translate(${dimensions().margin.left},${dimensions().margin.top})`}\n          >\n            <Show when={props.showGrid !== false}>\n              <g class=\"grid\" ref={gridRef} />\n            </Show>\n\n            <For each={props.data}>\n              {(series, index) => {\n                const color = () => getSeriesColor(series, index());\n\n                return (\n                  <g class=\"series\">\n                    <For each={series.data}>\n                      {(point) => (\n                        <circle\n                          cx={xScale()(point.x as number & Date)}\n                          cy={yScale()(point.y)}\n                          fill={color()}\n                          fill-opacity={props.pointOpacity ?? 0.7}\n                          r={point.size ?? props.pointRadius ?? 6}\n                          stroke={color()}\n                          stroke-width={1}\n                        />\n                      )}\n                    </For>\n                  </g>\n                );\n              }}\n            </For>\n\n            <g\n              class=\"x-axis\"\n              ref={xAxisRef}\n              transform={`translate(0,${dimensions().innerHeight})`}\n            />\n            <g class=\"y-axis\" ref={yAxisRef} />\n\n            <Show when={props.xAxisLabel}>\n              <text\n                fill={chartStyles.axis.text}\n                font-size={chartStyles.axis.fontSize}\n                text-anchor=\"middle\"\n                x={dimensions().innerWidth / 2}\n                y={dimensions().innerHeight + dimensions().margin.bottom - 5}\n              >\n                {props.xAxisLabel}\n              </text>\n            </Show>\n\n            <Show when={props.yAxisLabel}>\n              <text\n                fill={chartStyles.axis.text}\n                font-size={chartStyles.axis.fontSize}\n                text-anchor=\"middle\"\n                transform=\"rotate(-90)\"\n                x={-dimensions().innerHeight / 2}\n                y={-dimensions().margin.left + 15}\n              >\n                {props.yAxisLabel}\n              </text>\n            </Show>\n          </g>\n        </svg>\n\n        <Show when={props.showLegend !== false && props.data.length > 1}>\n          <div class=\"mt-4 flex flex-wrap justify-center gap-4\">\n            <For each={props.data}>\n              {(series, index) => (\n                <div class=\"flex items-center gap-2\">\n                  <span\n                    class=\"h-3 w-3 rounded-full\"\n                    style={{ background: getSeriesColor(series, index()) }}\n                  />\n                  <span class=\"text-muted-foreground text-sm\">\n                    {series.name}\n                  </span>\n                </div>\n              )}\n            </For>\n          </div>\n        </Show>\n\n        <Show when={tooltip.isVisible()}>\n          <div\n            class=\"pointer-events-none absolute z-50 rounded-md border px-3 py-2 shadow-md\"\n            style={{\n              left: `${tooltip.state().position.x + 10}px`,\n              top: `${tooltip.state().position.y + 10}px`,\n              background: chartStyles.tooltip.background,\n              border: `1px solid ${chartStyles.tooltip.border}`,\n              color: chartStyles.tooltip.text,\n              \"box-shadow\": chartStyles.tooltip.shadow,\n            }}\n          >\n            <div class=\"flex items-center gap-2\">\n              <span\n                class=\"h-2 w-2 rounded-full\"\n                style={{ background: tooltip.state().data?.color }}\n              />\n              <span class=\"font-medium\">\n                {tooltip.state().data?.seriesName}\n              </span>\n            </div>\n            <div class=\"mt-1 text-muted-foreground text-sm\">\n              <div>X: {formatTooltipX(tooltip.state().data?.x)}</div>\n              <div class=\"font-medium text-foreground\">\n                Y: {formatTooltipY(tooltip.state().data?.y)}\n              </div>\n              <Show when={tooltip.state().data?.label}>\n                <div class=\"text-xs\">{tooltip.state().data?.label}</div>\n              </Show>\n            </div>\n          </div>\n        </Show>\n      </Show>\n    </div>\n  );\n};\n\nexport default ScatterChart;\n"
    }
  ]
}
