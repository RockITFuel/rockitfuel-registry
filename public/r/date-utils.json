{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "date-utils",
  "type": "registry:lib",
  "title": "Date Utilities",
  "description": "Date conversion and parsing utilities for Dutch date format support",
  "dependencies": [
    "@internationalized/date",
    "date-fns"
  ],
  "files": [
    {
      "path": "lib/date-utils.ts",
      "type": "registry:lib",
      "content": "import {\n\tCalendarDate,\n\tfromDate,\n\tgetLocalTimeZone,\n\ttoCalendarDate,\n\ttype ZonedDateTime,\n} from \"@internationalized/date\";\nimport { isValid } from \"date-fns\";\n\nconst DEFAULT_TIMEZONE = \"Europe/Amsterdam\";\n\n/**\n * Convert a JavaScript Date object to a CalendarDate object\n *\n * @param jsDate - The JavaScript Date object to convert\n * @returns A CalendarDate object representing the same date\n */\nexport function jsDateToCalendarDate(jsDate: Date): CalendarDate {\n\treturn toCalendarDate(fromDate(jsDate, getLocalTimeZone()));\n}\n\n/**\n * Convert a CalendarDate object to a JavaScript Date object\n *\n * @param calendarDate - The CalendarDate object to convert\n * @param timeZone - The time zone to use for conversion (defaults to Europe/Amsterdam)\n * @returns A JavaScript Date object representing the same date\n */\nexport function calendarDateToJsDate(\n\tcalendarDate: CalendarDate,\n\ttimeZone: string = DEFAULT_TIMEZONE,\n): Date {\n\treturn calendarDate.toDate(timeZone);\n}\n\n/**\n * Convert a JavaScript Date to a ZonedDateTime\n *\n * @param jsDate - The JavaScript Date object to convert\n * @param timeZone - The time zone to use (defaults to Europe/Amsterdam)\n * @returns A ZonedDateTime object\n */\nexport function jsDateToZonedDateTime(\n\tjsDate: Date,\n\ttimeZone: string = DEFAULT_TIMEZONE,\n): ZonedDateTime {\n\treturn fromDate(jsDate, timeZone);\n}\n\n/**\n * Convert a ZonedDateTime to a JavaScript Date\n *\n * @param zonedDateTime - The ZonedDateTime object to convert\n * @returns A JavaScript Date object\n */\nexport function zonedDateTimeToJsDate(zonedDateTime: ZonedDateTime): Date {\n\treturn zonedDateTime.toDate();\n}\n\n/**\n * Convert a date string (YYYY-MM-DD) to a CalendarDate\n *\n * @param dateString - The date string in YYYY-MM-DD format\n * @returns A CalendarDate object\n */\nexport function dateStringToCalendarDate(dateString: string): CalendarDate {\n\tconst [year, month, day] = dateString.split(\"-\").map(Number);\n\tif (!year || !month || !day) {\n\t\tthrow new Error(\n\t\t\t`Invalid date string format: ${dateString}. Expected format: YYYY-MM-DD`,\n\t\t);\n\t}\n\treturn new CalendarDate(year, month, day);\n}\n\n/**\n * Convert a CalendarDate to a date string (YYYY-MM-DD)\n *\n * @param calendarDate - The CalendarDate object to convert\n * @returns A date string in YYYY-MM-DD format\n */\nexport function calendarDateToDateString(calendarDate: CalendarDate): string {\n\treturn calendarDate.toString();\n}\n\n/**\n * Safely convert any date-like value to a CalendarDate\n *\n * @param value - A Date object, number (timestamp), or date string\n * @returns A CalendarDate object or null if conversion fails\n */\nexport function toCalendarDateSafe(\n\tvalue: Date | number | string | undefined | null,\n): CalendarDate | null {\n\tif (!value) return null;\n\n\ttry {\n\t\tif (value instanceof Date) {\n\t\t\treturn jsDateToCalendarDate(value);\n\t\t}\n\n\t\tif (typeof value === \"number\") {\n\t\t\treturn jsDateToCalendarDate(new Date(value));\n\t\t}\n\n\t\tif (typeof value === \"string\") {\n\t\t\t// Handle YYYY-MM-DD format\n\t\t\tif (/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n\t\t\t\treturn dateStringToCalendarDate(value);\n\t\t\t}\n\t\t\t// Handle other date string formats\n\t\t\treturn jsDateToCalendarDate(new Date(value));\n\t\t}\n\n\t\treturn null;\n\t} catch (error) {\n\t\tconsole.warn(\"Failed to convert value to CalendarDate:\", value, error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Safely convert a CalendarDate to a JavaScript Date\n *\n * @param calendarDate - The CalendarDate to convert\n * @param timeZone - The time zone to use for conversion\n * @returns A JavaScript Date object or null if conversion fails\n */\nexport function toJsDateSafe(\n\tcalendarDate: CalendarDate | null | undefined,\n\ttimeZone: string = DEFAULT_TIMEZONE,\n): Date | null {\n\tif (!calendarDate) return null;\n\n\ttry {\n\t\treturn calendarDateToJsDate(calendarDate, timeZone);\n\t} catch (error) {\n\t\tconsole.warn(\n\t\t\t\"Failed to convert CalendarDate to Date:\",\n\t\t\tcalendarDate,\n\t\t\terror,\n\t\t);\n\t\treturn null;\n\t}\n}\n\n/**\n * Parse a Dutch-formatted date input string into a Date object.\n * Supports multiple input formats:\n * - With separators: \"02-02-2025\", \"02/02/2025\", \"2-2-2025\", \"2/2/25\"\n * - Without separators: \"02022025\" (8 digits), \"2022025\" (7 digits), \"222025\" (6 digits)\n *\n * For 2-digit years: 00-29 → 2000-2029, 30-99 → 1930-1999\n *\n * @param input - The user input string to parse\n * @returns A valid Date object or null if parsing fails\n */\nexport function parseDutchDateInput(input: string): Date | null {\n\tif (!input || input.trim() === \"\") return null;\n\n\tconst trimmed = input.trim();\n\n\t// Check if input contains separators (- or /)\n\tif (trimmed.includes(\"-\") || trimmed.includes(\"/\")) {\n\t\treturn parseDateWithSeparators(trimmed);\n\t}\n\n\t// No separators - parse as digits only\n\treturn parseDateWithoutSeparators(trimmed);\n}\n\n/**\n * Parse date string with separators (dd-MM-yyyy, dd/MM/yyyy, d-M-yy, etc.)\n */\nfunction parseDateWithSeparators(input: string): Date | null {\n\t// Split by - or /\n\tconst parts = input.split(/[-/]/);\n\tif (parts.length !== 3) return null;\n\n\tconst dayStr = parts[0];\n\tconst monthStr = parts[1];\n\tconst yearStr = parts[2];\n\n\tif (!dayStr || !monthStr || !yearStr) return null;\n\n\tconst day = Number.parseInt(dayStr, 10);\n\tconst month = Number.parseInt(monthStr, 10);\n\tlet year = Number.parseInt(yearStr, 10);\n\n\tif (Number.isNaN(day) || Number.isNaN(month) || Number.isNaN(year)) {\n\t\treturn null;\n\t}\n\n\t// Handle 2-digit years\n\tif (year < 100) {\n\t\tyear = year <= 29 ? 2000 + year : 1900 + year;\n\t}\n\n\treturn createValidDate(day, month, year);\n}\n\n/**\n * Parse date string without separators (ddMMyyyy, dMMyyyy, ddMyyyy, dMyyyy)\n * Format assumption: DD MM YYYY (Dutch format)\n */\nfunction parseDateWithoutSeparators(input: string): Date | null {\n\t// Remove any non-digit characters\n\tconst digits = input.replace(/\\D/g, \"\");\n\n\t// Need at least 6 digits (d+m+yyyy) and at most 8 (dd+mm+yyyy)\n\tif (digits.length < 6 || digits.length > 8) return null;\n\n\t// Extract year (always last 4 digits for full year, or last 2 for short year)\n\tlet year: number;\n\tlet remaining: string;\n\n\tif (digits.length >= 6) {\n\t\t// Check if we have a 4-digit year or 2-digit year\n\t\t// Strategy: try 4-digit year first (more common for explicit input)\n\t\tif (digits.length >= 6 && digits.length <= 8) {\n\t\t\t// Assume last 4 digits are year if we have 6-8 digits\n\t\t\tconst yearStr = digits.slice(-4);\n\t\t\tyear = Number.parseInt(yearStr, 10);\n\t\t\tremaining = digits.slice(0, -4);\n\n\t\t\t// If year seems invalid (like 0202 when user typed 2022025),\n\t\t\t// try treating last 2 as year\n\t\t\tif (year < 1900 || year > 2100) {\n\t\t\t\tconst shortYearStr = digits.slice(-2);\n\t\t\t\tconst shortYear = Number.parseInt(shortYearStr, 10);\n\t\t\t\tyear = shortYear <= 29 ? 2000 + shortYear : 1900 + shortYear;\n\t\t\t\tremaining = digits.slice(0, -2);\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t} else {\n\t\treturn null;\n\t}\n\n\t// Now parse day and month from remaining digits (2-4 digits)\n\t// remaining could be: \"dd\" + \"mm\" (4 digits), \"d\" + \"mm\" (3 digits),\n\t// \"dd\" + \"m\" (3 digits), or \"d\" + \"m\" (2 digits)\n\tconst dayMonth = parseRemainingDayMonth(remaining);\n\tif (!dayMonth) return null;\n\n\treturn createValidDate(dayMonth.day, dayMonth.month, year);\n}\n\n/**\n * Parse the remaining day+month digits after year extraction\n * Tries different combinations to find a valid date\n */\nfunction parseRemainingDayMonth(\n\tremaining: string,\n): { day: number; month: number } | null {\n\tconst len = remaining.length;\n\n\tif (len < 2 || len > 4) return null;\n\n\t// Generate possible interpretations\n\tconst possibilities: Array<{ day: number; month: number }> = [];\n\n\tif (len === 4) {\n\t\t// DD MM format\n\t\tpossibilities.push({\n\t\t\tday: Number.parseInt(remaining.slice(0, 2), 10),\n\t\t\tmonth: Number.parseInt(remaining.slice(2, 4), 10),\n\t\t});\n\t} else if (len === 3) {\n\t\t// Could be D MM or DD M\n\t\tpossibilities.push({\n\t\t\tday: Number.parseInt(remaining.slice(0, 1), 10),\n\t\t\tmonth: Number.parseInt(remaining.slice(1, 3), 10),\n\t\t});\n\t\tpossibilities.push({\n\t\t\tday: Number.parseInt(remaining.slice(0, 2), 10),\n\t\t\tmonth: Number.parseInt(remaining.slice(2, 3), 10),\n\t\t});\n\t} else if (len === 2) {\n\t\t// D M format\n\t\tpossibilities.push({\n\t\t\tday: Number.parseInt(remaining.slice(0, 1), 10),\n\t\t\tmonth: Number.parseInt(remaining.slice(1, 2), 10),\n\t\t});\n\t}\n\n\t// Return first valid combination\n\tfor (const p of possibilities) {\n\t\tif (isValidDayMonth(p.day, p.month)) {\n\t\t\treturn p;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Check if day and month values are within valid ranges\n */\nfunction isValidDayMonth(day: number, month: number): boolean {\n\treturn day >= 1 && day <= 31 && month >= 1 && month <= 12;\n}\n\n/**\n * Create a Date object and validate it's a real date\n * (e.g., rejects 31-02-2025)\n */\nfunction createValidDate(\n\tday: number,\n\tmonth: number,\n\tyear: number,\n): Date | null {\n\t// Basic range check\n\tif (\n\t\tday < 1 ||\n\t\tday > 31 ||\n\t\tmonth < 1 ||\n\t\tmonth > 12 ||\n\t\tyear < 1900 ||\n\t\tyear > 2100\n\t) {\n\t\treturn null;\n\t}\n\n\t// Create date (month is 0-indexed in JS Date)\n\tconst date = new Date(year, month - 1, day);\n\n\t// Validate the date is real by checking if the values match\n\t// (Date auto-corrects invalid dates, e.g., Feb 31 becomes Mar 3)\n\tif (\n\t\tdate.getFullYear() !== year ||\n\t\tdate.getMonth() !== month - 1 ||\n\t\tdate.getDate() !== day\n\t) {\n\t\treturn null;\n\t}\n\n\t// Double-check with date-fns isValid\n\tif (!isValid(date)) {\n\t\treturn null;\n\t}\n\n\treturn date;\n}\n\n/**\n * Format a Date object to Dutch date string (dd-MM-yyyy)\n *\n * @param date - The Date object to format\n * @returns Formatted string in dd-MM-yyyy format\n */\nexport function formatDutchDate(date: Date): string {\n\tconst day = date.getDate().toString().padStart(2, \"0\");\n\tconst month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n\tconst year = date.getFullYear();\n\treturn `${day}-${month}-${year}`;\n}\n"
    }
  ]
}